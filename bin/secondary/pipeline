#!/usr/bin/env perl

#Copyright (C) <2012>  <Yunfei Guo>

##This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

##This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

##You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.


use warnings;
use strict;
#use diagnostics;
use FindBin qw/$RealBin/;
use File::Spec;
use lib File::Spec->catdir($RealBin,"..","..","lib");
use Pod::Usage qw/pod2usage/;
use Getopt::Long qw/GetOptions/;
use File::Copy qw/copy move/;
use File::Basename qw/basename dirname/;
use SeqMule::Utils;
use SeqMule::Parallel;
use SeqMule::SeqUtils;

#CONSTANTS
my $PHRED_SCORE_CHECK_LINECOUNT = 1000;
my $HG18REF="human_b36_both.fasta";
my $HG19REF="human_g1k_v37.fasta";
my $GATKLITE_HARD_FILTER_BAM_SIZE=1_000_000_000; #in bytes, BAM files smaller than it will be subject to SNP hard filtering instead of VQSR
my $GATKLITE_INDEL_HARD_FILTER_BAM_SIZE=15_000_000_000; #in bytes, BAM files smaller than it will be subject to indel hard filtering instead of VQSR
my $GATK_HARD_FILTER_BAM_SIZE=1_000_000_000; #in bytes, BAM files smaller than it will be subject to SNP hard filtering instead of VQSR
my $GATK_INDEL_HARD_FILTER_BAM_SIZE=15_000_000_000; #in bytes, BAM files smaller than it will be subject to indel hard filtering instead of VQSR
my $RMDUP_MIN_LEN=10_000_000; #remove minimum 
my $SAMTOOLS_SORT_MEM_EXOME = '2G';
my $SAMTOOLS_SORT_MEM_GENOME = '2G'; #2G has been tested to work with wgs
my $TMPDIR = $ENV{TMPDIR} || "/tmp";
my %VARIANT_QUAL_PRIORITY_LIST = (
    gatk_hc => 1,
    gatk_ug =>2,
    gatklite => 3,
    freebayes => 4,
    samtools =>5,
    varscan =>6,
    soapsnp=>7);

#cmd opt
my (
    $prefix,$fq1,$fq2,$bam,$merge,$mergingrule,$multi_sample_calling,$minN,
    $buildver, $pl, $rg, $lb, $phred, $wes, $wgs, $force_one_rg,$union_rg,
    $threads, $quick, $java_mem, $tmpdir, $gatk_nt, $advanced,$norun,$nostat,$noremove,$force_rm_dup,
    $no_resolve_conflict,
    $capture,$ref, $index_prefix, $bowtie_index_prefix, $bowtie2_index_prefix, 
    $soap_index_prefix, $hapmap, $dbsnp,  $dbsnpver,  $kg, $indel,
    $verbose, $help, 
);

#GLOBAL VARIABLES
my $install_dir=File::Spec->catdir($RealBin,"..","..");
my %loc; #record all found exes, files such that no need to search again
my @prefix_list;
my $analysis_prefix; #used for report folder, script name etc
my %original_input;
my @fq1_list;
my @fq2_list;
my @bam_list;
my @merging_rule_list;

#readgroup information
my @readgroup;
my @library;
my @platform;

#intermediate files
my @obj_list;
my @bam_files; #intermediate BAM files
my @soapaln_file;
my @vcf_files;
my @consensus_vcf;
my @presplit_bam;
my @presplit_original_bam; #original BAM files prior to splitting
my @aligners;
my @callers; #lowercase, variant callers, including gatklite, gatk_ug, gatk_hc,samtools,snver,freebayes,varscan, soapsnp
my %soapaln_sample;
my @small_bed;

#files for calculating statistics only
my @bam_for_aln_stat;

my ($paired,$fq_toggle,$somatic_toggle)=(0,0,0);
my $script_file;
my $log;
my @commands;
#regular mode: ([1,"samtools"],[12,"bwa"])
#SGE mode (NOT IMPLEMENTED): ([1,"2g","samtools"],[12,"2g","bwa"])
my $date=`date +%m%d%Y`; chomp $date;

#files to be cleaned
my @removable; #unimportant intermediate files, remove at user's choice
my @script_unlink_list; #list consiting of temporarily generated file, should be removed at the end of generated script

#------------------------------------------------------------------------------------------------


#default values will be set at parsing advanced_config
@ARGV or pod2usage ({-exitval=>2});
GetOptions(
    #input and output
    'prefix|p=s'	=>	\$prefix,
    'a=s'	        =>	\$fq1,
    'b=s'	        =>	\$fq2,
    'bam=s'		=>	\$bam,
    'merge|m'		=>	\$merge,
    'mergingrule=s'	=>	\$mergingrule,
    'ms'		=>	\$multi_sample_calling,
    'N=i'		=>	\$minN,
    #analysis param
    'build=s'	        =>	\$buildver,
    'platform|pl=s'	=> 	\$pl,
    'readgroup|rg=s'    =>	\$rg,
    'forceOneRG'	=>	\$force_one_rg,
    'unionRG'		=>	\$union_rg,
    'library|lb=s'	=>	\$lb,
    'phred=i'	        =>	\$phred,
    'wes|e'		=>	\$wes,
    'wgs|g'		=>	\$wgs,
    #runtime parameters
    'threads|t=i'	=>	\$threads,
    'quick|q'		=>	\$quick,
    'jmem=s'		=>	\$java_mem,
    'tmpdir=s'		=>	\$tmpdir,
    'gatknt=i'		=>	\$gatk_nt,
    'advanced:s'	=>	\$advanced,
    'norun|nr'	        =>	\$norun,
    'nostat|ns'	        =>	\$nostat,
    'norm'		=>	\$noremove,
    'forceRmDup'	=>	\$force_rm_dup,
    #associated db
    'capture=s'		=>	\$capture,
    'no-resolve-conflict'=>	\$no_resolve_conflict,
    'ref=s'	        =>	\$ref,
    'index=s'	        =>	\$index_prefix,
    'bowtie=s'	        =>	\$bowtie_index_prefix,
    'bowtie2=s'	        =>	\$bowtie2_index_prefix,
    'soap=s'	        =>	\$soap_index_prefix,
    'hapmap=s'	        =>	\$hapmap,
    'dbsnp=s'	        =>	\$dbsnp,
    'dbsnpver|dv=i'	=>	\$dbsnpver,
    'kg=s'	        =>	\$kg,
    'indel=s'		=>	\$indel, #indel gold standard
    #other
    'verbose|v'	        =>	\$verbose,
    'help|h'	        =>	\$help,
) or pod2usage({-exitval => 2});
$help||@ARGV and pod2usage ({-verbose=>1});


#option check
&optCheck();
&advanceConfFileCheck(); 
&prefixCheck() if $prefix;
&parseGlobalConf(); #all configurations are stored in global vars
&confOptCheck(); #check again after options are deteremined
&checkMerge(); #check if merging rule is reasonable based on number of samples and files, this must be done even if merging is not enabled
#internally, SeqMule does not completely differentiate between merging and non-merging
&procFQ() if $fq1;
&procBAM() if $bam;
&checkForSplit() if $quick;
&genAnalysisPrefix();
&reportParam();
#script generation and running and stats
&genScript();
#execution
warn "To execute it, execute 'seqmule run $script_file'\n" and exit 0 if $norun;
#don't add die for the following command, it will die itself upon failure
exec File::Spec->catfile($install_dir,"bin","seqmule"),"run",$script_file;

#-----------------------------------subroutines--------------------------------------------
#
sub checkMerge
{
    my $file_count = $fq_toggle? @fq1_list:@bam_list;
    #set merging rule
    if ($mergingrule)
    {
	@merging_rule_list = split /,/,$mergingrule;
    } else
    { #by default, seqmule tries to assign the files evenly among samples
	@merging_rule_list = (int ($file_count/@prefix_list)) x @prefix_list;
    }
    if(&SeqMule::Utils::sum(@merging_rule_list) != $file_count)
    {
	die "ERROR: total number of files specified by merging rule is not equal to number of input files\n".
	"It is also possible that SeqMule fails to assign integer number of files to each sample equally.\n".
	"Parsed merging rule: @merging_rule_list\n".
	"Number of files: $file_count\n".
	"Number of samples: ".(scalar @prefix_list)."\n";
    }
    if(grep {$_ <= 0} @merging_rule_list)
    {
	die "ERROR: all numbers in merging rule should be larger than 0\n";
    }
}

sub genAnalysisPrefix
{
    my @tmp=@prefix_list;
    if(@tmp>4)
    {
	warn "NOTICE: when there are over four samples, the first 4 sample names are used as analysis name.\n";
	@tmp=@tmp[0,1,2,3];
    }
    $analysis_prefix=join('-',@tmp);
}
sub getExe
{
    for my $exename(@_)
    {
	if ($loc{$exename})
	{
	    return $loc{$exename};
	} else
	{
	    if(my $exepath=&SeqMule::Utils::search($install_dir,$exename))
	    {
		$loc{$exename}=$exepath;
		return $exepath;
	    }
	}
    }
    die "ERROR: Failed to find @_\n";
}

#cmd_gen is very specific
sub cmd_gen 
{

    my ($n,$program,$subprogram,$options_ref)=@_;
    warn "***Preparing $program\n\n" if $verbose;
    $program=lc $program;

    if ($program eq 'fastqc') 
    {
	return &fastqc(@_);
    } 
    elsif ($program eq 'bwa')
    {
	return unless $fq_toggle;
	push @aligners,"bwa";
	return &bwa(@_);
    } 
    elsif ($program eq 'bwamem')
    {
	return unless $fq_toggle;
	push @aligners,"bwamem";
	return &bwa_mem(@_);
    } 
    elsif ($program eq 'bowtie') 
    {
	return unless $fq_toggle;
	push @aligners,"bowtie";
	return &bowtie(@_);
    }
    elsif ($program eq 'bowtie2') 
    {
	return unless $fq_toggle;
	push @aligners,"bowtie2";
	return &bowtie2(@_);
    }
    elsif ($program eq 'soap') 
    {
	return unless $fq_toggle;
	push @aligners,"soap";
	return &soap(@_);
    }
    elsif ($program eq 'snap')
    {
	return unless $fq_toggle;
	push @aligners,"snap";
	return &snap(@_);
    }
    elsif ($program eq 'samtools') 
    {
	return &samtools(@_);
    }
    elsif ($program eq 'varscan')
    {
	return &varscan(@_);
    }
    elsif ($program eq 'picard')
    {
	return &picard(@_);
    }
    elsif ($program eq 'gatklite') 
    {
	return &gatk(@_);
    }
    elsif ($program eq 'gatk') 
    {
	return &gatk_full(@_);
    }
    elsif ($program eq 'freebayes') 
    {
	return &freebayes(@_);
    }
    elsif ($program eq 'snver') 
    {
	return &snver(@_);
    }
    elsif ($program eq 'soapsnp')
    {
	return &soapsnp(@_);
    }
    else {die "ERROR: Unrecognized program: $program\n"}
}

#subroutines for each external program
sub fastqc
{
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my $fastqc = &getExe(&SeqMule::Utils::getProgramExe("fastqc"));

    warn "FastQC executable: $fastqc\n" if $verbose;
    my $extractSummary = File::Spec->catfile($install_dir,"bin","secondary","convertQCstat");

    for my $i(@obj_list)
    {
	my $sample = $i->sample();
	my $result_folder = &get_result_folder($sample);
	my $qcstat = File::Spec->catfile($result_folder,"${sample}_qc_stat.txt");
	my $alias = join("_",(map {basename $_->file()} $i->ancestor()));
	unlink $qcstat or die "ERROR: Failed to remove $qcstat: $!" if -e $qcstat or -l $qcstat; #remove existing $qcstat since the following command append ouput to it (not overwrite)
	push @commands, [$threads,"QC assesment on input",
	    "$fastqc --extract ".
	    ($threads >=2 ? " -t $threads ":" ").
	    $i->file() ];
	push @commands,[$threads,"Generate QC stat","$extractSummary ".$i->file()." $alias $qcstat"]; 
    }
}

sub bwa
{
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};

    my $bwa=&getExe(&SeqMule::Utils::getProgramExe("bwa")); 
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools")); 
    my $sortsam=&getExe("SortSam.jar"); 
    my $java="java"; 
    my $runbwa=File::Spec->catfile($install_dir,"bin","secondary","runBWA");
    my $local_ref;
    my $aligner = "bwa";

    if ($ref) 
    {
	$local_ref=$ref;
    } else
    {
	$local_ref=($buildver eq 'hg19'? $HG19REF:$HG18REF);
	my $original=File::Spec->catfile($install_dir,"database",$local_ref);
	my $link=File::Spec->catfile($install_dir,"database","bwa",$local_ref);
	die "ERROR: No reference genome in $install_dir/database (did you download it?)\n" unless -f $original;
	symlink $original,$link unless -e $link;
	$local_ref=$link;
    }

    &index_check("bwa",$local_ref) or die "BWA index file(s) missing\n";

    for my $i(@obj_list)
    {
	next unless $i->filetype eq 'FASTQ' and $i->rank == 0;
	my $local_prefix= &SeqMule::Utils::getFQprefix($i->file());
	my @local_fq_obj = ($i,$i->sibling());
	my @local_fq;
	my @sai;
	my $local_bam_obj = $i->clone();
	my $local_bam="${local_prefix}_$aligner.sort.bam";
	my $cmd;

	$local_bam_obj->aligner($aligner);
	$local_bam_obj->file($local_bam);
	$local_bam_obj->parent(@local_fq_obj);
	$local_bam_obj->filetype('BAM');
	map{$_->child($local_bam_obj)} (@local_fq_obj);

	push @local_fq,map {$_->file()} (@local_fq_obj);

	push @sai,map {"${local_prefix}_$aligner.$_.sai"; } (0..$#local_fq_obj);
	push @script_unlink_list,@sai;

	$cmd = "$runbwa -advanced $advanced -n $n -bwa $bwa -samtools $samtools -java $java -jmem $java_mem".
	" -sortsam $sortsam -ref $local_ref -bam $local_bam ".
	" -threads $threads ".
	" -rg ".$i->rg().
	" -sample ".$i->sample.
	" -pl ".$i->pl().
	" -lb ".$i->lb().
	" -tmpdir $TMPDIR";
	map {$cmd.=" -fq $_ ";} @local_fq;
	map {$cmd.=" -sai $_ ";} @sai;

	push @commands,[$threads,"BWA-BACKTRACK alignment",$cmd];
	push @obj_list,$local_bam_obj;
	push @removable,$local_bam;
    }
}

sub bwa_mem
{
    #output example
    #./bwa mem -R '@RG\tID:foo\tSM:bar' -M -t 12 ~/projects/seqmule_main/database/bwa/human_g1k_v37.fasta ../s4.1.fastq ../s4.2.fastq
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};

    my $bwa=&getExe(&SeqMule::Utils::getProgramExe("bwa")); 
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools")); 
    my $sortsam=&getExe("SortSam.jar"); 
    my $java="java"; 
    my $runBwamemCMD=File::Spec->catfile($install_dir,"bin","secondary","runBWA-MEM");
    my $local_ref;
    my $aligner = "bwamem";

    die "ERROR: BWA-MEM cannot handle Phred 64 base quality score\n" if $phred == 64;

    if ($ref) 
    {
	$local_ref=$ref;
    } else
    {
	$local_ref=($buildver eq 'hg19'? $HG19REF:$HG18REF);
	my $original=File::Spec->catfile($install_dir,"database",$local_ref);
	my $link=File::Spec->catfile($install_dir,"database","bwa",$local_ref);
	die "ERROR: No reference genome in $install_dir/database (did you download it?)\n" unless -f $original;
	symlink $original,$link unless -e $link;
	$local_ref=$link;
    }

    &index_check("bwa",$local_ref) or die "BWA index file(s) missing\n";

    for my $i(@obj_list)
    {
	next unless $i->filetype eq 'FASTQ' and $i->rank == 0 ;
	my $local_prefix= &SeqMule::Utils::getFQprefix($i->file());
	my @local_fq_obj = ($i,$i->sibling());
	my @local_fq;
	my $local_bam_obj = $i->clone();
	my $local_bam="${local_prefix}_$aligner.sort.bam";
	my $cmd;

	push @local_fq,map {$_->file()} (@local_fq_obj);
	$local_bam_obj->aligner($aligner);
	$local_bam_obj->file($local_bam);
	$local_bam_obj->parent(@local_fq_obj);
	$local_bam_obj->filetype('BAM');
	map{$_->child($local_bam_obj)} (@local_fq_obj);


	$cmd.="$runBwamemCMD -advanced $advanced -n $n -bwa $bwa -samtools $samtools ".
	" -java $java -jmem $java_mem -sortsam $sortsam -ref $local_ref ".
	" -bam ".$local_bam_obj->file().
	" -threads $threads ".
	" -rg ".$local_bam_obj->rg().
	" -sample ".$local_bam_obj->sample().
	" -pl ".$local_bam_obj->pl().
	" -lb ".$local_bam_obj->lb().
	" -tmpdir $TMPDIR".
	" @local_fq";

	push @commands,[$threads,"BWA alignment",$cmd];
	push @obj_list,$local_bam_obj;
	push @removable,$local_bam;
    }
}

sub snap
{
    #output example
    #./bwa mem -R '@RG\tID:foo\tSM:bar' -M -t 12 ~/projects/seqmule_main/database/bwa/human_g1k_v37.fasta ../s4.1.fastq ../s4.2.fastq
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};

    my $snap=&getExe(&SeqMule::Utils::getProgramExe("snap")); 
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools")); 
    my $runSnapCMD=File::Spec->catfile($install_dir,"bin","secondary","runSNAP");
    my $interleave_fq = &getExe(&SeqMule::Utils::getProgramExe("interleave_fastq"));
    my $local_ref;
    my $aligner = "snap";

    die "ERROR: SNAP cannot handle Phred+64 score\n" if $phred == 64;

    if ($ref) 
    {
	$local_ref=$ref;
    } else
    {
	$local_ref=($buildver eq 'hg19'? $HG19REF:$HG18REF);
	my $original=File::Spec->catfile($install_dir,"database",$local_ref);
	my $link=File::Spec->catfile($install_dir,"database","snap",$local_ref);
	$local_ref=$link;
    }

    &index_check("snap",$local_ref) or die "ERROR: SNAP index file(s) missing\n";

    #this part can be improved
    #SNAP can run multiple alignments without reloading index
    for my $i(@obj_list)
    {
	next unless $i->filetype eq 'FASTQ' and $i->rank == 0;
	my $local_prefix= &SeqMule::Utils::getFQprefix($i->file());
	my @local_fq_obj = ($i,$i->sibling());
	my @local_fq;
	my $local_bam_obj = $i->clone();
	my $local_bam="${local_prefix}_$aligner.sort.bam";
	my $cmd;

	push @local_fq,map {$_->file()} (@local_fq_obj);
	$local_bam_obj->file($local_bam);
	$local_bam_obj->aligner($aligner);
	$local_bam_obj->parent(@local_fq_obj);
	$local_bam_obj->filetype('BAM');
	map{$_->child($local_bam_obj)} (@local_fq_obj);

	$cmd.="$runSnapCMD -advanced $advanced -n $n -snap $snap -samtools $samtools ".
	" -ref $local_ref ".
	" -bam ".$local_bam_obj->file().
	" -threads $threads ".
	" -rg ".$local_bam_obj->rg().
	" -sample ".$local_bam_obj->sample().
	" -pl ".$local_bam_obj->pl().
	" -lb ".$local_bam_obj->lb().
	" -sortmem ".($wes? $SAMTOOLS_SORT_MEM_EXOME:$SAMTOOLS_SORT_MEM_GENOME).
	" -tmpdir $TMPDIR".
	" -interleave_fq $interleave_fq ".
	" @local_fq";

	push @commands,[$threads,"SNAP alignment",$cmd];
	push @obj_list,$local_bam_obj;
	push @removable,$local_bam;
    }
}
sub bowtie
{
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};

    my $bowtie=&getExe(&SeqMule::Utils::getProgramExe("bowtie")); 
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools")); 
    my $sortsam=&getExe("SortSam.jar"); 
    my $java="java"; 
    my $runBowtieCMD=File::Spec->catfile($install_dir,"bin","secondary","runBOWTIE");
    my $local_real_index;
    my $aligner = "bowtie";


    #check if all indexes exist; keep the real name of the indexes
    if ($bowtie_index_prefix)
    {
	#bowtie index can also appear in bowtie dir, in env
	my $exe_folder=dirname(&SeqMule::Utils::abs_path_failsafe($bowtie));

	my @index_pres;
	push @index_pres, $bowtie_index_prefix,File::Spec->catfile($exe_folder,"indexes",$bowtie_index_prefix);
	push @index_pres, File::Spec->catfile($ENV{BOWTIE_INDEXES},$bowtie_index_prefix) if defined $ENV{BOWTIE_INDEXES};
	for (@index_pres) 
	{
	    if (&index_check("bowtie",$_))
	    {
		$local_real_index=$_;
		last;
	    }
	}
    } else {
	my ($hg18_pre)= $HG18REF=~/(.*)\.(.*)$/;
	my ($hg19_pre)= $HG19REF=~/(.*)\.(.*)$/;
	my $default_index=File::Spec->catfile($install_dir,"database","bowtie",($buildver eq 'hg18' ? $hg18_pre : $hg19_pre));

	if (&index_check("bowtie",$default_index))
	{
	    $local_real_index=$default_index;
	} 
    } 
    die "ERROR: No bowtie indexe files (prefix.1.ebwt etc.) found\n" unless $local_real_index;

    for my $i(@obj_list)
    {
	next unless $i->filetype eq 'FASTQ' and $i->rank == 0;
	my $local_prefix= &SeqMule::Utils::getFQprefix($i->file());
	my @local_fq_obj = ($i,$i->sibling());
	my @local_fq;
	my $local_bam_obj = $i->clone();
	my $local_bam="${local_prefix}_$aligner.sort.bam";
	my $cmd;

	push @local_fq,map {$_->file()} (@local_fq_obj);
	$local_bam_obj->file($local_bam);
	$local_bam_obj->aligner($aligner);
	$local_bam_obj->parent(@local_fq_obj);
	$local_bam_obj->filetype('BAM');
	map{$_->child($local_bam_obj)} (@local_fq_obj);

	$cmd="$runBowtieCMD -advanced $advanced -n $n -bowtie $bowtie ".
	" -samtools $samtools -java $java -jmem $java_mem -sortsam $sortsam ".
	" -ref $local_real_index ".
	" -bam ".$local_bam_obj->file().
	" -threads $threads ".
	" -rg ".$local_bam_obj->rg().
	" -sample ".$local_bam_obj->sample().
	" -pl ".$local_bam_obj->pl().
	" -lb ".$local_bam_obj->lb().
	" -tmpdir $TMPDIR".
	" @local_fq";

	push @commands,[$threads,"Bowtie alignment",$cmd];
	push @obj_list,$local_bam_obj;
	push @removable,$local_bam;
    }
}

sub bowtie2
{
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    my $bowtie2=&getExe(&SeqMule::Utils::getProgramExe("bowtie2")); 
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools")); 
    my $sortsam=&getExe("SortSam.jar"); 
    my $java="java"; 
    my $runBowtie2CMD=File::Spec->catfile($install_dir,"bin","secondary","runBOWTIE2");
    my $local_real_index;
    my $aligner = "bowtie2";

    #check if all indexes exist; keep the real name of the indexes
    if ($bowtie2_index_prefix)
    {
	#bowtie index can also appear in bowtie dir, in env
	my $exe_folder=dirname(&SeqMule::Utils::abs_path_failsafe($bowtie2));

	my @index_pres;
	push @index_pres, $bowtie2_index_prefix,File::Spec->catfile($exe_folder,"indexes",$bowtie2_index_prefix);
	push @index_pres, File::Spec->catfile($ENV{BOWTIE2_INDEXES},$bowtie2_index_prefix) if defined $ENV{BOWTIE2_INDEXES};
	for (@index_pres) 
	{
	    if (&index_check("bowtie",$_))
	    {
		$local_real_index=$_;
		last;
	    }
	}
    } else {
	my ($hg18_pre)= $HG18REF=~/(.*)\.(.*)$/;
	my ($hg19_pre)= $HG19REF=~/(.*)\.(.*)$/;
	my $default_index=File::Spec->catfile($install_dir,"database","bowtie2",($buildver eq 'hg18' ? $hg18_pre : $hg19_pre));

	if (&index_check("bowtie2",$default_index))
	{
	    $local_real_index=$default_index;
	} 
    } 
    die "No index files ({prefix}.1.bt2 etc.) found\n" unless $local_real_index;

    for my $i(@obj_list)
    {
	next unless $i->filetype eq 'FASTQ' and $i->rank == 0;
	my $local_prefix= &SeqMule::Utils::getFQprefix($i->file());
	my @local_fq_obj = ($i,$i->sibling());
	my @local_fq;
	my $local_bam_obj = $i->clone();
	my $local_bam="${local_prefix}_$aligner.sort.bam";
	my $cmd;

	push @local_fq,map {$_->file()} (@local_fq_obj);
	$local_bam_obj->file($local_bam);
	$local_bam_obj->aligner($aligner);
	$local_bam_obj->parent(@local_fq_obj);
	$local_bam_obj->filetype('BAM');
	map{$_->child($local_bam_obj)} (@local_fq_obj);

	$cmd="$runBowtie2CMD -advanced $advanced -n $n -bowtie2 $bowtie2 ".
	" -samtools $samtools -java $java -jmem $java_mem ".
	" -sortsam $sortsam -ref $local_real_index ".
	" -bam ".$local_bam_obj->file().
	" -threads $threads ".
	" -rg ".$local_bam_obj->rg().
	" -sample ".$local_bam_obj->sample().
	" -pl ".$local_bam_obj->pl().
	" -lb ".$local_bam_obj->lb().
	" -tmpdir $TMPDIR".
	" @local_fq";

	push @commands,[$threads,"Bowtie2 alignment",$cmd];
	push @obj_list,$local_bam_obj;
	push @removable,$local_bam;
    }
}
sub soap
{
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    my $exe=&getExe(&SeqMule::Utils::getProgramExe("soap")); 
    my $exe_soap2sam=File::Spec->catfile($install_dir,"bin","soap2sam.pl");
    my $runsoap=File::Spec->catfile($install_dir,"bin","secondary","runSOAP");
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools")); 
    my $sortsam=&getExe("SortSam.jar"); 
    my $java="java"; 
    my $local_real_index;
    my $aligner = "soap";

    if ($soap_index_prefix) 
    {
	if (&index_check("soap",$soap_index_prefix))
	{
	    $local_real_index=$soap_index_prefix;
	}
    }
    else {
	my $hg18_pre="$HG18REF.index";
	my $hg19_pre="$HG19REF.index";
	my $default_index=File::Spec->catfile($install_dir,"database","soap",($buildver eq 'hg18'? $hg18_pre:$hg19_pre));
	if (&index_check("soap",$default_index))
	{
	    $local_real_index=$default_index;
	} 
    } 
    die "ERROR: No SOAP index files ({prefix}.amb etc.) found\n" unless $local_real_index;
    #generate command for multiple input files
    for my $i(@obj_list)
    {
	next unless $i->filetype eq 'FASTQ' and $i->rank == 0;
	my $local_prefix= &SeqMule::Utils::getFQprefix($i->file());
	my $local_sam="${local_prefix}_$aligner.sam";
	my $local_bam="${local_prefix}_${aligner}.sort.bam";
	my $unpaired="${local_prefix}_${aligner}_unpaired.soapout";
	my $unmapped="${local_prefix}_${aligner}_unmapped.soapout";
	my $alnfile="${local_prefix}_${aligner}.soapaln";
	my @local_fq_obj = ($i,$i->sibling());
	my @local_fq;
	my $local_bam_obj = $i->clone();
	my $local_soapaln_obj = $i->clone();
	my $cmd;

	push @local_fq,map {$_->file()} (@local_fq_obj);
	$local_bam_obj->file($local_bam);
	$local_bam_obj->parent(@local_fq_obj);
	$local_bam_obj->filetype('BAM');
	$local_bam_obj->aligner($aligner);
	$local_soapaln_obj->file($alnfile);
	$local_soapaln_obj->parent(@local_fq_obj);
	$local_soapaln_obj->filetype('SOAPALN');
	$local_soapaln_obj->aligner($aligner);
	map{$_->child($local_bam_obj,$local_soapaln_obj)} (@local_fq_obj);

	$cmd.=" $runsoap ";
	$cmd.=" -soap $exe ";
	$cmd.=" -index $local_real_index ";
	$cmd.=" -n $n -advanced $advanced ".
	" -bam ".$local_bam_obj->file().
	" -rg ".$local_bam_obj->rg().
	" -sample ".$local_bam_obj->sample().
	" -pl ".$local_bam_obj->pl().
	" -lb ".$local_bam_obj->lb();
	$cmd.=" -sam $local_sam ";
	$cmd.=" -sortsam $sortsam ";
	$cmd.=" -java $java -jmem $java_mem ";
	$cmd.=" -samtools $samtools ";
	$cmd.=" -soap2sam $exe_soap2sam ";
	$cmd.=" -threads $threads";
	$cmd.=" -unmapped $unmapped";
	if (@local_fq == 2) {    
	    $cmd.=" -fq $local_fq[0] -fq $local_fq[1] -soapaln $alnfile -unpaired $unpaired";
	} else {
	    $cmd.="-fq $local_fq[0] -soapaln $alnfile";
	}
	push @commands,[$threads,"SOAP2 alignment",$cmd];

	push @script_unlink_list,$local_sam,$unpaired,$unmapped;
	push @obj_list,$local_bam_obj,$local_soapaln_obj;
	push @removable,$local_bam,$alnfile;
    }
} 
sub samtools
{
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    my $exe=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
    my $faidx="$local_ref.fai";
    if ($subprogram=~/index/i) 
    {
	if ($fq_toggle && $merge)
	{
	    #merge by aligner, sample combination
	    for my $i(@aligners)
	    {
		for my $j(0..$#prefix_list)
		{
		    my $sample = $prefix_list[$j];
		    my $result_folder = &get_result_folder($sample);
		    my $onebam=File::Spec->catfile($result_folder,$sample."_$i.merge.bam");
		    my @one_aligner_sample_bam = grep {
		    $_->aligner() eq $i && 
		    $_->filetype eq 'BAM' &&
		    $_->sample() eq $sample 
		    } @obj_list;
		    #remove the unmerged BAM from obj_list
		    #they will no longer be processed
		    SeqMule::SeqUtils->rmObjFromArray(
			target=>\@one_aligner_sample_bam,
			all=>\@obj_list,
		    );

		    my $onebam_obj = $one_aligner_sample_bam[0]->clone();
		    $onebam_obj->parent(@one_aligner_sample_bam);
		    $onebam_obj->file($onebam);
		    map {$_->child($onebam_obj) } @one_aligner_sample_bam;

		    if(@one_aligner_sample_bam == 1)
		    {
			push @commands, [$threads,"Merge BAM for $i and $sample",join(" ","cp",$one_aligner_sample_bam[0]->file(),$onebam_obj->file())];
		    } else
		    {
			push @commands, [$threads,"Merge BAM for $i and $sample",
			    "$exe merge -f ".
			    $onebam_obj->file().' '.
			    join(' ',map{$_->file()} @one_aligner_sample_bam).
			    ($threads>=2? " -@ $threads ":" ")
			];
		    }
		    #save merged obj in obj_list
		    push @obj_list,$onebam_obj; 
		    push @removable,$onebam_obj->file();
		}
	    }
	}

	map { push @commands, [$threads,"Index BAM file","$exe index ".$_->file()] } (grep {$_->filetype() eq 'BAM'} @obj_list);

    } elsif($subprogram=~/filter/i)
    {
	my $readfilter=File::Spec->catfile($install_dir,"bin","secondary","readFilter");
	for my $i(@obj_list)
	{
	    next unless $i->filetype eq 'BAM';
	    my $bam = $i->file();
	    my ($local_prefix)= $bam=~/(.*?)\.bam$/i or die "ERROR: expect .bam suffix: $bam\n";
	    my $new_obj = $i->clone();
	    my $out="$local_prefix.readfiltered.bam";
	    $new_obj->parent($i);
	    $new_obj->file($out);
	    $i->child($new_obj);

	    my $cmd="$readfilter -samtools $exe -bam $bam -out $out -threads $threads -n $n -advanced $advanced ";
	    push @commands, [$threads,"Filter BAM file",$cmd];
	    push @removable,$bam; #this bam is no long essential for downstream analysis, can be deleted at user's discretion
	    $i=$new_obj;
	}
    }elsif ($subprogram=~/mpileup/i) 
    {
	my $mode;
	my $caller = 'samtools';
	my $bcftools=&getExe("bcftools");
	my $vcfutils=&getExe("vcfutils.pl");
	my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
	my $exe=File::Spec->catfile($install_dir,"bin","secondary","runSAMTOOLS");
	my $header_check=File::Spec->catfile($install_dir,"bin","secondary","sameBAMSQ");
	my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
	my $faidx="$local_ref.fai";
	my $local_threads=($quick? 1 : $threads); #if quick mode, define a local version of $threads, set it to 1
	my $cmd_common="$exe -advanced $advanced -n $n -samtools $samtools -bcftools $bcftools -vcfutils $vcfutils -ref $local_ref -tmpdir $TMPDIR ";

	#add PATH for bcftools
	$ENV{PATH}=($ENV{PATH}? $ENV{PATH}.":":"").File::Spec->catdir(dirname($samtools),"bcftools");
	push @commands,[$local_threads,"Index reference genome","$samtools faidx $local_ref"] unless -e $faidx;

	warn "NOTICE: SAMtools will enable mapping quality downgrading for BWA input (if any).\n" if ($options{bwaDownGrade});

	my @target_obj;
	if ($options{'originalBAM'}) {
	    #this step is to make sure we use BAM files without realn or recal if users want to
	    @target_obj = grep {$_->realn() == 0 && $_->recal() == 0} @obj_list;
	} else {
	    @target_obj = grep {$_->realn() == 1 || $_->recal() == 1} @obj_list;
	}

	&check_obj(@target_obj);
	$mode = ($multi_sample_calling? 'multi':'single');
	#previously we have to treat BAMs differently depending on
	#whether they come from FASTQ files
	#now we solely depend on aligner of each BAM
	#if it comes from FASTQ, it has an non-empty string denoting the aligner
	#otherwise its aligner attribute is an empty string ''
	for my $i(SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list))
	{
	    #do multi-sample calling for bam files from the same aligner
	    my @bam_obj = grep {$_->filetype eq 'BAM'} @target_obj;
	    @bam_obj = grep {$_->aligner eq $i} @bam_obj;
	&check_obj(@bam_obj);
	    &gen_variant_call_cmd({
		    mode=>$mode,
		    caller=>$caller,
		    callcmd=>$cmd_common,
		    bam=>\@bam_obj
		});
	}
    } elsif ($subprogram=~/rmdup/i)
    {
	for my $i(@obj_list)
	{
	    next unless $i->filetype() eq 'BAM';
	    my $bam = $i->file();
	    my ($local_prefix)= $bam=~/(.*?)\.bam$/i or die "ERROR: expect .bam suffix: $bam\n";
	    my $new_obj = $i->clone();
	    my $out = "$local_prefix.rmdup.bam";
	    $new_obj->parent($i);
	    $new_obj->file($out);
	    $i->child($new_obj);

	    my $cmd.="$exe rmdup $bam $out";
	    push @commands,[$threads,"Remove duplicates in $bam",$cmd];
	    push @removable,$bam; #this bam is no long essential for downstream analysis, can be deleted at user's discretion
	    $i = $new_obj;
	}
    }else {die "ERROR: Unrecognized subprogram for SAMtools: $subprogram\n"}
}

sub freebayes
{
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    my $caller='freebayes';
    my $mode;
    my $run_freebayes=&getExe("runFREEBAYES");
    my $freebayes=&getExe( &SeqMule::Utils::getProgramExe("Freebayes") );
    my $samtools=&getExe( &SeqMule::Utils::getProgramExe("samtools") );
    my $vcfsorter = File::Spec->catfile($install_dir,"bin","secondary","vcfsorter");
    my $header_check=File::Spec->catfile($install_dir,"bin","secondary","sameBAMSQ");
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
    my $local_threads=($quick? 1 : $threads); #if quick mode, define a local version of $threads, set it to 1
    my $cmd_common="$run_freebayes -advanced $advanced -n $n -freebayes $freebayes -vcfsorter $vcfsorter -ref $local_ref -samtools $samtools -tmpdir $TMPDIR ";

    my @target_obj;
    if ($options{'originalBAM'})
    {
	#this step is to make sure we use BAM files without realn or recal if users want to
	@target_obj = grep {$_->realn() == 0 && $_->recal() == 0} @obj_list;
    } else
    {
	@target_obj = grep {$_->realn() == 1 || $_->recal() == 1} @obj_list;
    }

    $mode = ($multi_sample_calling? 'multi':'single');
    #previously we have to treat BAMs differently depending on
    #whether they come from FASTQ files
    #now we solely depend on aligner of each BAM
    #if it comes from FASTQ, it has an non-empty string denoting the aligner
    #otherwise its aligner attribute is an empty string ''
    for my $i(SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list))
    {
	#do multi-sample calling for bam files from the same aligner
	my @bam_obj = grep {$_->filetype eq 'BAM'} @target_obj;
	@bam_obj = grep {$_->aligner eq $i} @bam_obj;
	&gen_variant_call_cmd({
		mode=>$mode,
		caller=>$caller,
		callcmd=>$cmd_common,
		bam=>\@bam_obj
	    });
    }
}

##########################################
##########################################
##########################################
##########################################
##########################################
##########################################
######SNVER needs to be modified###########
######SNVER needs to be modified###########
######SNVER needs to be modified###########
######SNVER needs to be modified###########
######SNVER needs to be modified###########
sub snver
{
    my $caller='snver';
    push @callers,$caller;

    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    my $samtools=&getExe("samtools");
    my $stats=File::Spec->catfile($install_dir,"bin","secondary","stats");
    my $java="java";
    my $snver=&getExe("SNVerIndividual.jar");
    my $runSnverCMD=File::Spec->catfile($install_dir,"bin","secondary","runSNVER");
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
    my $local_threads=($quick? 1 : $threads); #if quick mode, define a local version of $threads, set it to 1
    my $faidx="$local_ref.fai";
    my @target_bam_files;
    my $cmd_common="$runSnverCMD -advanced $advanced -n $n -java $java -jmem $java_mem -snver $snver -stats $stats -ref $local_ref -samtools $samtools -tmpdir $TMPDIR ";

    if ($options{'originalBAM'})
    {
	#this step is to make sure we use BAM files without realn or recal
    } else
    {
	#if ($quick && ! @presplit_bam)
	@target_bam_files=@bam_files;
    }

    push @commands,[$threads,"Index reference genome","$samtools faidx $local_ref"] unless -e $faidx;

    for my $local_bam(@target_bam_files) 
    {
	if ($quick)
	{
	    for my $i(1..$threads)
	    {
		my $bed=$small_bed[$i-1];

		my ($local_prefix)=$local_bam=~/(.*)\.bam$/i;
		$local_prefix=File::Spec->catfile((dirname $local_prefix),"_${i}_.".(basename $local_prefix));
		my $cmd_prefix="${local_prefix}_snver";
		my $local_vcf_filter="${cmd_prefix}.filter.vcf";
		my $cmd=$cmd_common;

		$cmd.=" -bam $local_bam -prefix $cmd_prefix ";
		$cmd.=" -bed $bed " if $bed;

		push @commands,[$local_threads,"SNVer variant calling",$cmd];
		push @vcf_files,$local_vcf_filter;
	    }
	} else
	{
	    my $bed=$capture;
	    my ($local_prefix)=$local_bam=~/(.*)\.bam$/i;
	    my $cmd_prefix="${local_prefix}_snver";
	    my $local_vcf_filter="${cmd_prefix}.filter.vcf";
	    my $cmd=$cmd_common;

	    $cmd.=" -bam $local_bam -prefix $cmd_prefix ";
	    $cmd.=" -bed $bed " if $bed;

	    push @commands,[$local_threads,"SNVer variant calling",$cmd];
	    push @vcf_files,$local_vcf_filter;
	}
    }
}

########################gatklite################################
sub gatk
{
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};

    if ($subprogram=~/realign/i) 
    {
	warn "CAUTION: SOAPaligner output might not be able to be processed by GATKLite\n" and sleep 1 if (grep { /soap/ } @aligners);

	&gen_gatk_realign_recal_cmd($n,"gatklite","realn",\%options);
    } 
    elsif ($subprogram=~/recal/i) 
    {
	warn "CAUTION: GATKLite base quality reclibration COVARIATE options will not be examined for syntax\n" if $options{covariates};
	warn "CAUTION: SOAPaligner output might not be able to be processed by GATKLite\n" and sleep 1 if (grep { /soap/ } @aligners);
	die "ERROR: No covariates for base quality recalibration\n" if $options{covariates} eq "";

	&gen_gatk_realign_recal_cmd($n,"gatklite","recal",\%options);
    } 
    elsif ($subprogram=~/variant/) 
    {
	my $caller='gatklite';
	my $mode;
	my $exe=&getExe(&SeqMule::Utils::getProgramExe("gatklite"));
	my $exe_java="java";
	my $runGATKCMDFILTER=File::Spec->catfile($install_dir,"bin","secondary","runGATKLITEFILTER");
	my $runGATKCMDCALL=File::Spec->catfile($install_dir,"bin","secondary","runGATKLITECALL");

	my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
	my $local_dbsnp=&SeqMule::Utils::search_db({type=>"dbsnp",target=>$dbsnp,build=>$buildver,version=>$dbsnpver,install_dir=>$install_dir});
	my $local_hapmap=&SeqMule::Utils::search_db({type=>"hapmap",target=>$hapmap,build=>$buildver,install_dir=>$install_dir});
	my $local_kg=&SeqMule::Utils::search_db({type=>"kg",target=>$kg,build=>$buildver,install_dir=>$install_dir});
	my $local_indel=&SeqMule::Utils::search_db({type=>"indel",target=>$indel,build=>$buildver,install_dir=>$install_dir});

	my $local_threads=($quick? 1 : $threads); #if quick mode, define a local version of $threads, set it to 1
	#sanity check for filter expression
	for my $i($options{indelfilters}, $options{snpfilters})
	{
	    for my $filter(split ';',$i)
	    {
		my ($filtername,$filterexp)=split ',',$filter;
		die "Missing filter name or expression for GATKLite indel/SNP filtering.\n" unless ($filtername && $filterexp);
	    }
	}
	my $cmd_common_filter="$runGATKCMDFILTER -advanced $advanced  -n $n -gatk-hfilter-size $GATKLITE_HARD_FILTER_BAM_SIZE -gatk-indelfilter-size $GATKLITE_INDEL_HARD_FILTER_BAM_SIZE -ref $local_ref -hapmap $local_hapmap -kg $local_kg -dbsnp $local_dbsnp -goldindel $local_indel -java $exe_java -jmem $java_mem -gatk $exe -threads $local_threads -gatk-nt $gatk_nt --tmpdir $TMPDIR ";
	my $cmd_common_call="$runGATKCMDCALL -advanced $advanced  -n $n -ref $local_ref -java $exe_java -jmem $java_mem -gatk $exe -threads $local_threads -gatk-nt $gatk_nt -tmpdir $TMPDIR ";
	warn "CAUTION: GATKLite variant recalibration annotation options will not be examined for syntax\n" if $options{annotations} ne "";
	warn "CAUTION: SOAPaligner output might not be able to be processed by GATKLite\n" and sleep 1 if (grep { /soap/ } (SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list)));

	my @target_obj;

	if ($options{'originalBAM'})
	{
	    #this step is to make sure we use BAM files without realn or recal if users want to
	    @target_obj = grep {$_->realn() == 0 && $_->recal() == 0} @obj_list;
	} else
	{
	    @target_obj = grep {$_->realn() == 1 || $_->recal() == 1} @obj_list;
	}
	$mode = ($multi_sample_calling? 'multi':'single');

	for my $i(SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list))
	{
	    #do multi-sample calling for bam files from the same aligner
	    my @bam_obj = grep {$_->filetype eq 'BAM'} @target_obj;
	    @bam_obj = grep {$_->aligner eq $i} @bam_obj;

	    &gen_variant_call_cmd({
		    mode		=>	$mode,
		    caller		=>	$caller,
		    callcmd		=>	$cmd_common_call,
		    filtercmd		=>	$options{filter} ? $cmd_common_filter: undef,
		    bam			=>	\@bam_obj,
		});
	}
    }
    else
    { 
	die "ERROR: Unrecognized subprogram $subprogram for GATKLite.\n";
    }
}

sub gen_gatk_realign_recal_cmd
{
    my $n = shift;
    my $version = shift; #gatklite vs gatkfull?
    my $operation = shift; #realn vs recal
    my %options=%{shift @_};
    my $exe;
    my $exe_java="java";
    my $exe_samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
    my $local_indel=&SeqMule::Utils::search_db({type=>"indel",target=>$indel,build=>$buildver,install_dir=>$install_dir});
    my $local_dbsnp=&SeqMule::Utils::search_db({type=>"dbsnp",target=>$dbsnp,build=>$buildver,version=>$dbsnpver,install_dir=>$install_dir});
    my $run_gatk;

    if($version eq 'gatklite') {
	$exe = &getExe(&SeqMule::Utils::getProgramExe("gatklite"));
	if($operation eq 'realn') {
	    $run_gatk = File::Spec->catfile($install_dir,"bin","secondary","runGATKLITEREALN");
	} elsif ($operation eq 'recal') {
	    $run_gatk = File::Spec->catfile($install_dir,"bin","secondary","runGATKLITERECAL");
	} else {
	    die "ERROR: unknown GATK operation: $operation\n";
	}
    } elsif ($version eq 'gatkfull') {
	$exe = &getExe(&SeqMule::Utils::getProgramExe("gatk"));
	if($operation eq 'realn') {
	    $run_gatk = File::Spec->catfile($install_dir,"bin","secondary","runGATKFULLREALN");

	} elsif ($operation eq 'recal') {
	    $run_gatk = File::Spec->catfile($install_dir,"bin","secondary","runGATKFULLRECAL");
	} else {
	    die "ERROR: unknown GATK operation: $operation\n";
	}
    } else {
	die "ERROR: unknown GATK version: $version\n";
    }

    my $cmd_common ="$run_gatk -advanced $advanced -n $n -ref $local_ref -java $exe_java -jmem $java_mem -gatk $exe -threads $threads -gatk-nt $gatk_nt -tmpdir $TMPDIR ";
    $cmd_common .= " -bed $capture" if $wes;
    $cmd_common .= " -goldindel $local_indel " if $local_indel;
    $cmd_common .= " -dbsnp $local_dbsnp " if $local_dbsnp;

    for my $local_bam_obj(@obj_list) 
    {
	next unless $local_bam_obj->filetype() eq 'BAM';
	my $local_bam = $local_bam_obj->file();
	my ($local_prefix)=$local_bam=~/(.*)\.bam$/i;
	my $newbam_obj = $local_bam_obj->clone();
	my $newbam = "${local_prefix}.$operation.bam";
	my $cmd = $cmd_common;

	$cmd .= " -pl ".$local_bam_obj->pl()." " if $local_bam_obj->pl();
	if($operation eq 'realn') {
	    $newbam_obj->realn(1);
	} elsif ($operation eq 'recal') {
	    $newbam_obj->recal(1);
	}
	$newbam_obj->file($newbam);
	$newbam_obj->parent($local_bam_obj);
	$local_bam_obj->child($newbam_obj);

	$cmd .= " -bam $local_bam -out $newbam ";
	push @commands,[$threads,"$version $operation",$cmd];
	push @commands,[$threads,"Index BAM files","$exe_samtools index $newbam"];
	#it's possible that some variant callers will use non-recal non-realn BAM
	#so we still keep the old BAM in @obj_list
	#$local_bam_obj = $newbam_obj; 
	push @removable,$newbam;
    }
}
#############end of gatklite#############

#################################gatk full version###########################
sub gatk_full
{
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    $subprogram=lc $subprogram;

    if ($subprogram eq 'realign') 
    {
	warn "CAUTION: SOAPaligner output might not be able to be processed by GATK\n" and sleep 1 if (grep { /soap/ } @aligners);

	&gen_gatk_realign_recal_cmd($n,"gatkfull","realn",\%options);
    } 
    elsif ($subprogram eq 'recal') 
    {
	warn "CAUTION: GATK base quality reclibration COVARIATE options will not be examined for syntax\n" if $options{covariates};
	warn "CAUTION: SOAPaligner output might not be able to be processed by GATK\n" and sleep 1 if (grep { /soap/ } @aligners);
	die "ERROR: No covariates for base quality recalibration\n" if $options{covariates} eq "";

	&gen_gatk_realign_recal_cmd($n,"gatkfull","recal",\%options);
    } 
    elsif ($subprogram eq 'unifiedgenotyper' || $subprogram eq 'haplotypecaller')
    {
	my $mode;
	my $exe=&getExe(&SeqMule::Utils::getProgramExe("gatk"));
	my $exe_java="java";
	my $runGATKCMDCALL=File::Spec->catfile($install_dir,"bin","secondary","runGATKFULLCALL");
	my $runGATKCMDFILTER=File::Spec->catfile($install_dir,"bin","secondary","runGATKFULLFILTER");

	my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
	my $local_dbsnp=&SeqMule::Utils::search_db({type=>"dbsnp",target=>$dbsnp,build=>$buildver,version=>$dbsnpver,install_dir=>$install_dir});
	my $local_hapmap=&SeqMule::Utils::search_db({type=>"hapmap",target=>$hapmap,build=>$buildver,install_dir=>$install_dir});
	my $local_kg=&SeqMule::Utils::search_db({type=>"kg",target=>$kg,build=>$buildver,install_dir=>$install_dir});
	my $local_indel=&SeqMule::Utils::search_db({type=>"indel",target=>$indel,build=>$buildver,install_dir=>$install_dir});

	my $local_threads=($quick? 1 : $threads); #if quick mode, define a local version of $threads, set it to 1

	#sanity check for filter expression
	for my $i($options{indelfilters}, $options{snpfilters})
	{
	    for my $filter(split ';',$i)
	    {
		my ($filtername,$filterexp)=split ',',$filter;
		die "Missing filter name or expression for GATK indel/SNP filtering.\n" unless ($filtername && $filterexp);
	    }
	}

	my $cmd_common_call="$runGATKCMDCALL -internal-caller $subprogram -advanced $advanced -n $n -ref $local_ref -java $exe_java -jmem $java_mem -gatk $exe -threads $local_threads -gatk-nt $gatk_nt -tmpdir $TMPDIR ";
	my $cmd_common_filter="$runGATKCMDFILTER -internal-caller $subprogram -advanced $advanced -n $n -gatk-hfilter-size $GATK_HARD_FILTER_BAM_SIZE  -gatk-indelfilter-size $GATK_INDEL_HARD_FILTER_BAM_SIZE -ref $local_ref -hapmap $local_hapmap -kg $local_kg  -dbsnp $local_dbsnp -goldindel $local_indel -java $exe_java -jmem $java_mem -gatk $exe -threads $local_threads -gatk-nt $gatk_nt --tmpdir $TMPDIR ";

	warn "CAUTION: GATK variant recalibration annotation options will not be examined for syntax\n" if $options{annotations} ne "";
	warn "CAUTION: SOAPaligner output might not be able to be processed by GATK UnifiedGenotyper.\n" and sleep 1 if (grep { /soap/ } @aligners);
	my @target_obj;
	my $caller=$subprogram eq 'unifiedgenotyper'?'gatk_ug':'gatk_hc';


	if ($options{'originalBAM'})
	{
	    #this step is to make sure we use BAM files without realn or recal if users want to
	    @target_obj = grep {$_->realn() == 0 && $_->recal() == 0} @obj_list;
	} else
	{
	    @target_obj = grep {$_->realn() == 1 || $_->recal() == 1} @obj_list;
	}

	$mode = ($multi_sample_calling? 'multi':'single');

	for my $i(SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list))
	{
	    #do multi-sample calling for bam files from the same aligner
	    my @bam_obj = grep {$_->filetype eq 'BAM'} @target_obj;
	    @bam_obj = grep {$_->aligner eq $i} @bam_obj;

	    &gen_variant_call_cmd({
		    mode		=>	$mode,
		    caller		=>	$caller,
		    callcmd		=>	$cmd_common_call,
		    filtercmd		=>	$options{filter} ? $cmd_common_filter: undef,
		    bam			=>	\@bam_obj,
		});
	}
    } else
    { 
	die "ERROR: Unrecognized subprogram $subprogram for GATK\n";
    }
}

############end of gatk full version##########

sub picard
{
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    my $exe_java="java";
    my $exe=&getExe("markduplicates.jar");
    if ($subprogram=~/markduplicates/i)
    {
	for my $local_bam_obj(@obj_list) 
	{
	    next unless $local_bam_obj->filetype() eq 'BAM';
	    my $cmd;
	    my $local_bam = $local_bam_obj->file();
	    my ($local_prefix)= $local_bam =~ /(.*)\.bam$/i;
	    my $newbam_obj = $local_bam_obj->clone();
	    my $newbam="$local_prefix.rmdup.bam";
	    my $metrics="${local_prefix}.rmdup.metrics";
	    $newbam_obj->file($newbam);
	    $newbam_obj->parent($local_bam_obj);
	    $local_bam_obj->child($newbam_obj);
	    #only mark duplicates, do not really remove them from BAM
	    $cmd.="$exe_java ";
	    $cmd.=" -Djava.io.tmpdir=$TMPDIR " if $TMPDIR;
	    $cmd.=" -Xmx$java_mem -jar $exe INPUT=$local_bam OUTPUT=$newbam METRICS_FILE=$metrics REMOVE_DUPLICATES=false VALIDATION_STRINGENCY=SILENT";
	    push @commands,[$threads,"Remove duplicates",$cmd];
	    $local_bam_obj = $newbam_obj;
	    push @removable,$newbam;
	}
    } else 
    {
	die "ERROR: Unrecognized subprogram for picard: $subprogram\n";
    }
}
sub varscan
{
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    my $mode;
    my $caller = 'varscan';
    my $exe=File::Spec->catfile($install_dir,"bin","secondary","runVARSCAN");
    my $varscan=&getExe(&SeqMule::Utils::getProgramExe("varscan"));
    my $java="java";
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
    my $cmd_common="$exe -advanced $advanced -n $n -samtools $samtools -java $java -jmem $java_mem -varscan $varscan -ref $local_ref -tmpdir $TMPDIR ";

    my @target_obj;

    if ($options{'originalBAM'})
    {
	#this step is to make sure we use BAM files without realn or recal if users want to
	@target_obj = grep {$_->realn() == 0 && $_->recal() == 0} @obj_list;
    } else
    {
	@target_obj = grep {$_->realn() == 1 || $_->recal() == 1} @obj_list;
    }
    $mode = ($multi_sample_calling? 'multi':'single');

    for my $i(SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list))
    {
	#do multi-sample calling for bam files from the same aligner
	my @bam_obj = grep {$_->filetype eq 'BAM'} @target_obj;
	@bam_obj = grep {$_->aligner eq $i} @bam_obj;
	&gen_variant_call_cmd({
		mode=>$mode,
		caller=>$caller,
		callcmd=>$cmd_common,
		bam=>\@bam_obj
	    });
    }
} 

sub gen_variant_call_cmd
{
    #for varscan, samtools and freebayes and GATK
    #figure out the mode of variant calling: multi-sample, somatic, single-sample
    #figure out what BAMs to use
    #call gen_cmd_for_variant_call_task to actually generate the command
    my $opt = shift;
    my $mode = $opt->{mode};
    my $caller = $opt->{caller};
    my $cmd_common = $opt->{callcmd};
    my $cmd_common_filter = $opt->{filtercmd};
    my @bam_obj = @{$opt->{bam}};
    while(@bam_obj) {
	#number of tasks, when quick is enabled, equal to number of threads
	my $ntask = $quick ? $threads : 1;
	my @bam_obj_for_this_task;
	my $suffix;
	#after we process a BAM, we remove it from the list to be processed
	if($mode eq 'multi') {
	    @bam_obj_for_this_task = @bam_obj;
	    @bam_obj = ();
	    die "ERROR: expect at least 2 BAM files for multi-sample variant calling.\n" unless @bam_obj_for_this_task >= 2;
	    $suffix = $caller.".multi-call";
	} elsif ($mode eq 'single') {
	    @bam_obj_for_this_task = shift @bam_obj;
	    $suffix = $caller;
	} elsif ($mode eq 'somatic') {
	    die "ERROR: Freebayes doesn't support somatic variant calling\n" if $caller eq 'freebayes';
	    $suffix = $caller.".somatic-call";
	    #for somatic calling, we need a pair of BAM, normal and tumor
	    my $random_obj = shift @bam_obj;
	    #before calling gen_variant_call_cmd, we have make sure
	    #the BAM files come from same aligner
	    my @same_sample_obj = grep { $_->sample() eq $random_obj->sample() } @bam_obj;

	    if(@same_sample_obj == 1) {
		#here we try to put normal first, tumor second
		if($random_obj->istumor() == 0 && $same_sample_obj[0]->istumor() == 1) {
		    push @bam_obj_for_this_task,$random_obj,$same_sample_obj[0];
		} elsif ($random_obj->istumor() == 1 && $same_sample_obj[0]->istumor() == 0) {
		    push @bam_obj_for_this_task,$same_sample_obj[0],$random_obj;
		}
		#remove somatic/normal pair from input list
		SeqMule::SeqUtils->rmObjFromArray(
		    target=>\@same_sample_obj,
		    all=>\@bam_obj
		);
	    } elsif(@same_sample_obj == 0) {
		die "ERROR: only found one BAM file for sample ".$random_obj->sample()."\n".
		"Somatic mutation calling cannot be performed\n";
	    } else {
		die "ERROR: Right now SeqMule can only handle 2 BAM files for one sample in\n".
		"somatic calling mode, we found ".(scalar @same_sample_obj+1)."\n";
	    }
	} else    {
	    die "ERROR: unrecognized mode ($mode) for samtools variant.\n";
	}
	my @sample_for_this_task = SeqMule::SeqUtils->get_attr_enum('sample',@bam_obj_for_this_task); 
	my @sibling_vcf = map {[]} (scalar @sample_for_this_task);
	print "bam_obj_for_this_task\n";
	&check_obj(@bam_obj_for_this_task);
	for my $i(0..($ntask-1)) {
	    my $bed = $quick? $small_bed[$i]:$capture;
	    #the empty array ref will be used to store VCF files for all VCF obj
	    #generated by one task

	    &gen_cmd_for_variant_call_task({
		    bed=>$bed,
		    bam=>\@bam_obj_for_this_task,
		    sibling_vcf=>\@sibling_vcf,
		    cmd		=>$cmd_common,
		    filter_flag	=>	0,
		    caller	=>	$caller,
		    suffix	=> 	$suffix,
		    task_idx	=>	$i,
		}
	    );
	}
	print "obj_list after all tasks\n";
	&check_obj(@obj_list);
	#VCF generated in each task is a sibling
	#to VCFs generated in all other tasks given that sample/input BAM is same
	#later all VCFs which are siblings to each will be merged
	for my $i(0..$#sibling_vcf) {
	    for my $j(@{$sibling_vcf[$i]}) {
		$j->sibling(@{$sibling_vcf[$i]});
	    }
	}
	if($cmd_common_filter) {
	    #if a separate filtering is to be done
	    #we can safely remove obj generated in variant calling stage
	    SeqMule::SeqUtils->rmObjFromArray(
		target	=>	[map {@$_} @sibling_vcf],
		all	=>	\@obj_list,
	    );

	    #if filter is necessary
	    #we have to provide all siblings
	    #do filtering just once, then copy results
	    #to other samples (if any)
	    &gen_cmd_for_variant_call_task({
		    #here we will not use split BED
		    #as the filtering step cannot be carried out
		    #as multiple processes
		    bed		=>	$capture,
		    bam		=>	\@bam_obj_for_this_task,
		    sibling_vcf	=>	\@sibling_vcf,
		    cmd		=>	$cmd_common_filter,
		    filter_flag	=>	1,
		    task_idx	=>	0,
		});
	}
    }
}

sub gen_cmd_for_variant_call_task
{
    #generate command and objects for variant calling/filtering step
    my $opt = shift;
    my $bed = $opt->{bed};
    my @bam_obj = @{$opt->{bam}};
    my @sibling_vcf = @{$opt->{sibling_vcf}};
    my @sample = SeqMule::SeqUtils->get_attr_enum('sample',@bam_obj); 
    my $cmd_common = $opt->{cmd};
    my $filter_flag = $opt->{filter_flag};
    my $suffix = $opt->{suffix};
    my $caller = $opt->{caller};
    my $i = $opt->{task_idx};
    my $local_threads=($quick? 1 : $threads); #if quick mode, define a local version of $threads, set it to 1

    #@sibling_vcf will keep track of siblings of each VCF
    #first array size is equal to # of samples
    #second array size is equal to # of tasks
    #creation and completion of this array is done outside this subroutine
    #
    #here we want to create a VCF for 
    #each sample
    for my $j(0..$#sample)
    {
	my ($bam_obj_for_this_sample) = grep { $_->sample() eq $sample[$j] } @bam_obj;
	my ($local_prefix) = ($bam_obj_for_this_sample->file() =~ /(.*)\.bam$/i);
	$local_prefix = $local_prefix.".$i";
	my $local_vcf = "${local_prefix}_$suffix.vcf";  
	#my $local_vcf_filter = "${local_prefix}_$suffix.filter.vcf"; 

	#we create a VCF object for each sample
	#but only use the first one in analysis
	#the rest are just copies
	#name of this obj contains 'filter',
	#but it is not necessarily filtered depending on 
	#$cmd_common_filter

	my $new_vcf_obj = $bam_obj_for_this_sample->clone();
	$new_vcf_obj->filetype('VCF');
	$new_vcf_obj->caller($caller);

	    $new_vcf_obj->file($local_vcf);
	if($filter_flag) {
	    #$new_vcf_obj->file($local_vcf_filter);
	} else {
	    #$new_vcf_obj->file($local_vcf);
	    #if a seperate filtering is performed
	    #then this VCF will NOT have siblings
	    #all siblings must have been merged before filtering
	    #otherwise why not do variant calling and filtering in the same step?
	    $new_vcf_obj->rank($i);
	}

	#only the first one is child of BAM input
	if($j==0) {
	    my $msg = $suffix; 
	    my $cmd = $cmd_common;
	    #$cmd.=" -vcf $local_vcf -vcf-filter $local_vcf_filter ";
	    $cmd.=" -vcf $local_vcf ";
	    $cmd.=" -bed $bed " if $bed;
	    if($filter_flag) {
		#parent is all sibling VCFs from variant calling step
		$new_vcf_obj->parent(@{$sibling_vcf[$j]});
		map {$cmd.=" -vcf-part ".$_->file()} $new_vcf_obj->parent();
		$msg .= " variant filtering";
	    } else {
		$new_vcf_obj->parent(@bam_obj);
		map {$cmd.=" -bam ".$_->file()} $new_vcf_obj->parent();
		$msg .= " variant calling";
	    }
		map { $_->child($new_vcf_obj) } $new_vcf_obj->parent();
	    push @commands,[$local_threads,$msg,$cmd];
	} else
	{
	    #for each BAM, variants are only called once
	    #the rest of VCFs are generated by copy if two VCFs share same input
	    my $vcf_template = $sibling_vcf[0][$i];
	    $new_vcf_obj->parent($vcf_template);
	    $vcf_template->child($vcf_template->child(),$new_vcf_obj);
	    #this step is necessary because result for each sample is supposed to be standalone
	    push @commands,[$local_threads,"Copy results to other samples","cp ".$vcf_template->file()." ".$new_vcf_obj->file()];
	}
	#note the index here is sample idx then task idx
	#VCFs of same sample idx will be siblings/merged later
	$sibling_vcf[$j][$i] = $new_vcf_obj;
	push @obj_list,$new_vcf_obj;
    }
}
sub soapsnp
{
    warn "soapsnp cmd generation\n" if $verbose;
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    my $soapsnp=&getExe(&SeqMule::Utils::getProgramExe("soapsnp"));
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
    my $soapsnp2vcf=File::Spec->catfile($install_dir,"bin","soapsnp2vcf");
    my $msort=&getExe("msort");
    my $runSoapsnp=File::Spec->catfile($install_dir,"bin","secondary","runSOAPSNP");
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
    my $local_threads=($quick? 1 : $threads); #if quick mode, define a local version of $threads, set it to 1
    my $cmd_common .= "$runSoapsnp -advanced $advanced -n $n -msort $msort -soapsnp $soapsnp -samtools $samtools -soapsnp2vcf $soapsnp2vcf -ref $local_ref ";
    my $caller = "soapsnp";

    for my $soap_obj(@obj_list) 
    {
	next unless $soap_obj->filetype() eq 'SOAPALN';
	my $soap_file = $soap_obj->file();
	my ($local_prefix) = $soap_file=~/(.*)\.soapaln$/i; 
	my $outfile = "${local_prefix}_$caller.consensus"; 
	my $vcf = "${local_prefix}_$caller.filter.vcf"; 
	my $sorted = "${local_prefix}.sort.soapaln"; 
	my $sample = $soap_obj->sample();
	my ($bam_obj) = grep {$_->sample() eq $sample and $_->filetype() eq 'BAM'} @obj_list;
	my $new_vcf_obj = $soap_obj->clone();
	my $new_soapaln_obj = $soap_obj->clone();
	my $cmd;

	$new_vcf_obj->caller($caller);
	$new_vcf_obj->file($vcf);
	$new_soapaln_obj->file($sorted);
	$new_vcf_obj->filetype('VCF');
	$new_soapaln_obj->filetype('SOAPALN');
	$new_vcf_obj->parent($soap_obj);
	$new_soapaln_obj->parent($soap_obj);
	$soap_obj->child($new_soapaln_obj,$new_vcf_obj);

	$cmd .= $cmd_common;
	$cmd .= " -in $soap_file ";
	$cmd .= " -bam ".$bam_obj->file();
	$cmd .= " -sample $sample ";
	$cmd .= " -sorted $sorted ";
	$cmd.=" -soapsnp-out $outfile -vcf $vcf ";

	push @commands,[$local_threads,"SOAPsnp variant calling",$cmd];
	push @script_unlink_list,$outfile;
	push @obj_list,$new_vcf_obj;
	#the unsorted soapaln file is no longer usefu
	$soap_obj = $new_soapaln_obj;
    }
} 

#check if index files exist                        
sub index_check
{
    my ($program,$prefix)=@_;

    if( $program=~/^soap$/i) {
	return
	(-e "$prefix.amb" && -e "$prefix.ann" && -e "$prefix.bwt" && -e "$prefix.fmv" && -e "$prefix.hot" && -e "$prefix.lkt" && -e "$prefix.pac" && -e "$prefix.rev.bwt" && -e "$prefix.rev.fmv" && -e "$prefix.rev.lkt" && -e "$prefix.rev.pac" && -e "$prefix.sa" && -e "$prefix.sai");

    } elsif ($program=~/^bowtie$/i) {
	return 
	(-e "$prefix.1.ebwt" && -e "$prefix.2.ebwt" && -e "$prefix.3.ebwt" && -e "$prefix.4.ebwt" && -e "$prefix.rev.1.ebwt" && -e "$prefix.rev.2.ebwt"); 

    } elsif ($program=~/^bowtie2$/i) {
	return
	(-e "$prefix.1.bt2" && -e "$prefix.2.bt2" && -e "$prefix.3.bt2" && -e "$prefix.4.bt2" && -e "$prefix.rev.1.bt2" && -e "$prefix.rev.2.bt2");

    } elsif ($program=~/^bwa$/i)
    {
	return (-e "$prefix.amb" && -e  "$prefix.bwt" && -e "$prefix.pac" && -e "$prefix.ann" && -e "$prefix.fai" && -e "$prefix.sa");
    } elsif ($program=~/^snap$/i)
    {
	return (-e File::Spec->catfile($prefix,"Genome") && -e  File::Spec->catfile($prefix,"GenomeIndex") && -e File::Spec->catfile($prefix,"GenomeIndexHash") && -e File::Spec->catfile($prefix,"OverflowTable"));
    } else { die "Unrecognized program for index check\n"}
}

sub parseGlobalConf
{
    #parse global configurations, store them in global variables
    open CONF,"<", $advanced or die "Cannot open $advanced: $!\n";
    #reading advanced_config 
    warn "Reading configuration file...\n";
    my @conf_lines;
    while (<CONF>) 
    {
	next if /^#|^\s+$/;
	chomp;
	next unless /^(go_.*=.*?)(\s|#|$)/i;
	push @conf_lines,$1;
    }
    close CONF;
    warn "Done\n";
    warn "NOTICE: Commandline options will override advanced configuration.\n";
    warn "NOTICE: Parsing global settings...\n";
    for (@conf_lines)
    {
	my ($key,$value)= /(go_\w+=)(.*?)(\s+|#|$)/;
	if ($key=~/_threads=/i) {
	    $threads=$threads || $value || 1;
	} elsif ($key=~/_jmem=/)
	{ $java_mem=$java_mem || $value || '1750m';
	}elsif ($key=~/_gatknt=/){
	    $gatk_nt=$gatk_nt || $value || 2;
	}elsif ($key=~/_platform=/i) {
	    $pl=$pl || $value || 'ILLUMINA';
	    $pl=uc $pl;
	} elsif ($key=~/_phred=/i) {
	    $phred=$phred || $value || 1;
	} elsif ($key=~/_rg=/i) {
	    $rg=$rg || $value || 'READGROUP';
	    $rg=uc $rg;
	} elsif ($key=~/_lb=/i) {
	    $lb=$lb || $value || 'LIBRARY';
	    $lb=uc $lb;
	} elsif ($key=~/_buildver=/) {
	    $buildver=$buildver || $value || 'hg19';
	} elsif ($key=~/_dbsnpver=/i) {
	    $dbsnpver=$dbsnpver || $value || 138;
	} elsif ($key=~/_dbsnp=/i) {
	    $dbsnp=$dbsnp || $value;
	} elsif ($key=~/_hapmap=/i) {
	    $hapmap=$hapmap || $value;
	} elsif ($key=~/_kg=/i) {
	    $kg=$kg || $value;
	} elsif ($key=~/_ref=/i) {
	    $ref=$ref || $value;
	} elsif ($key=~/_index=/) {
	    $index_prefix=$index_prefix || $value;
	} elsif ($key=~/_bowtie=/) {
	    $bowtie_index_prefix=$bowtie_index_prefix || $value;
	} elsif ($key=~/_bowtie2=/)
	{	$bowtie2_index_prefix=$bowtie2_index_prefix || $value    }
	elsif ($key=~/_soap=/)
	{ $soap_index_prefix=$soap_index_prefix || $value   }
	elsif ($key=~/_capture=/)
	{ 
	    $capture=$capture || $value;
	}
	else 
	{	warn "CAUTION:undefined global setting ignored: $key\n"    }

    }
    $bowtie_index_prefix=$bowtie_index_prefix || $index_prefix || "";
    $bowtie2_index_prefix=$bowtie2_index_prefix || $index_prefix || "";
    $soap_index_prefix=$soap_index_prefix || $index_prefix || "";
    warn "Done\n";
}

sub optCheck
{
    #check if options are specified properly, print necessary warnings
    if ($fq1 || $fq2 || $bam)
    {
	die "ERROR: use -g for whole-genome data, -e for exome (or captured) sequencing data\n" unless ($wes || $wgs);
	#die "No prefix. Use -p option.\n" unless $prefix;
	if ($fq1 || $fq2)
	{
	    die "ERROR: FASTQ and BAM files cannot be used together (-a or -b cannot work with -bam).\n" if $bam;
	    die "ERROR: first reads must be supplied together with second reads\n" if ($fq2 && !$fq1);
	    die "ERROR: No prefix given while FASTQ is supplied\n" unless $prefix;
	} else
	{
	    die "ERROR: No prefix given while merging files\n" if ($merge && !$prefix);
	}

    } else
    {
	#no input
	die "ERROR: no input files while merge is enabled\n" if $merge;
	die "ERROR: No input while advanced_config is specified\n" if $advanced;
	die "No input, exit\n" unless (defined $advanced); #argument of -advanced is optional
    }
    die "ERROR: -rg is missing while -forceOneRG is used.\n" if ($force_one_rg && !$rg);
    die "ERROR: no multiple readgroups allowed while -forceOneRG is used.\n" if ($force_one_rg && $rg=~/,/);
    die "ERROR: -forceOneRG cannot be used without -merge option.\n" if ($force_one_rg && !$merge);
    die "ERROR: -capture should NOT be used with -wgs/-g option. If you already have VCF files and want to calculate coverage statistics or extract variants in certain regions, please use 'seqmule stats -capture <BED> -vcf <VCF>'.\n" if $capture && $wgs;
    die "ERROR: -g -e cannot be specified together\n" if ($wes && $wgs);
    die "ERROR: '-capture <BED>' must specified for exome/captured data. Alternatively, you can use '-capture default' to analyze with default exome region definition.\nAll steps except alignment are done solely for the specified region.\nSome popular BED files can be downloaded by 'seqmule download -bed'.\n" if ($wes && !$capture);
    warn "CAUTION: You used your own reference file or index file, there is no guarantee that it will work with all programs.\n" if ($ref || $index_prefix || $bowtie_index_prefix || $bowtie2_index_prefix || $soap_index_prefix);
    warn "CAUTION: You used your own variant database, there is no guarantee that it will work with all programs.\n" if ($dbsnp || $kg || $hapmap);
    warn "Entering verbose mode...\n" if $verbose;

    #set temporary folder
    $TMPDIR = $tmpdir || $TMPDIR;

    #parse FQ file names
    $fq_toggle=1 if $fq1;
    $paired=1 if ($fq1 && $fq2);
    @fq1_list=split /,/,$fq1 if $fq1; @fq1_list= map { &SeqMule::Utils::abs_path_failsafe($_) } @fq1_list;
    @fq2_list=split /,/,$fq2 if $fq2; @fq2_list= map { &SeqMule::Utils::abs_path_failsafe($_) } @fq2_list;

    #parse BAM file names
    @bam_list=split /,/,$bam if $bam; 
    @bam_list= map { &SeqMule::Utils::abs_path_failsafe($_) } @bam_list;
}

sub advanceConfFileCheck
{
    #if $advanced is defined but empty, copy advanced_config and exit
    #otherwise assign its argument to $advanced for downstream processing
    my $conf_file= $advanced || File::Spec->catfile($install_dir,"misc","advanced_config");
#generate a template configuration file for customization
    if (defined $advanced) 
    {
	unless ($advanced)
	{
	    copy($conf_file,"advanced_config") or die "advanced_config copy failed: $!\n";
	    warn "'advanced_config' was copied to current directory.\n".
	    "To use it, 'seqmule pipeline -advanced advanced_config' along with other options\n";
	    warn "NOTICE: More predefined config files can be found inside ",File::Spec->catfile($install_dir,"misc","predefined_config"),"\n";
	    exit;
	}
    }
    $advanced=$conf_file;
}
sub prefixCheck
{
    #check prefix specification
    die "ERROR: No underscore/slash/back slash allowed in prefix, please consider using a hyphen instead\n" if $prefix=~/[\_\\\/]/;
    die "ERROR: No path allowed in prefix\n" if $prefix=~/[\\\/]/;
    @prefix_list=split /,/,$prefix;
    die "ERROR: Remove duplicate prefix: @prefix_list\n" unless @prefix_list == &SeqMule::Utils::uniq(@prefix_list);
    if ($multi_sample_calling)
    {
	@prefix_list >1 or die "At least two samples are required for multi-sample calling.\n";
    }

}

sub reportParam
{
    warn "NOTICE: Analysis name: $analysis_prefix\n" if $analysis_prefix;
    $fq_toggle ? warn "NOTICE: Input file type is FASTQ\n" : warn "NOTICE: Input file type is BAM\n";
    warn "NOTICE: All input is merged on a per-sample basis (after alignment if FASTQ).\n" if $merge;
    warn "NOTICE: Input is exome (or captured) sequencing data\n" if $wes;
    warn "NOTICE: Input is whole genome data\n" if $wgs; 
    warn "NOTICE: File used for caculating coverage statistics and extracting variants: ",(basename $capture),"\n" if $wes;
    warn "NOTICE: Readgroup : $rg\n";
    warn "NOTICE: Sequencing platform: $pl\n";
    warn "NOTICE: Library : $lb\n";
    warn "NOTICE: Phred scoring scheme : $phred\n" if $fq1;
    warn "NOTICE: Reference genome build is $buildver\n";
    warn "NOTICE: dbsnp$dbsnpver will be used for variant calling and recalibration.\n";
    warn "NOTICE: Java memory usage is limited to $java_mem\n";
    warn "NOTICE: Max number of processes: $threads\n";
    warn "NOTICE: Variants shared by at least $minN combinations of aligners and callers will be printed.\n" if $minN;
    if ($fq_toggle)
    {
	$paired ? warn "NOTICE: Two INPUT files detected, PAIRED ends mode\n" : warn "NOTICE: SINGLE end mode\n";
    }
    warn "NOTICE: Variant calling will be run in parallel mode [EXPERIMENTAL].\n" if $quick;
    warn "NOTICE: Multi-sample variant calling ENABLED.\n" if $multi_sample_calling;
    warn "NOTICE: $TMPDIR will be used for storing temporary files\n";

}

sub writeLog
{
    $log="$analysis_prefix.log";
    my @callers = SeqMule::SeqUtils->get_attr_enum('caller',@obj_list);
    my @aligners = SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list);
    warn "NOTICE: log file will be overwritten: $log\n" if -f $log;
    open LOG,'>',$log or die "Failed to write to $log: $!\n";

    #logging
    print LOG scalar @prefix_list," sample(s) in this analysis: @prefix_list\n";
    print LOG "All input is merged on a per-sample basis (after alignment if FASTQ).\n" if $merge;
    if (@prefix_list>1)
    {
	if ($multi_sample_calling)
	{
	    print LOG "Multi-sample variant calling ENABLED.\n";
	} else
	{
	    print LOG "Multi-sample variant calling DISABLED.\n";
	}
    }
    print LOG "Input is exome (or captured) sequencing data.\n" if $wes;
    print LOG "Input is whole genome sequencing data.\n" if $wgs;
    print LOG scalar @callers," variant caller(s) used: ",join(" ",&SeqMule::Utils::callers2names(@callers)),"\n" if @callers;
    print LOG scalar @aligners," aligner(s) used: @aligners\n" if @aligners;
    print LOG "Variants shared by at least $minN combinations of aligners and callers are printed.\n" if $minN;
    print LOG "File used for caculating coverage statistics and extracting variants: ",(basename $capture),"\n" if $wes;
    print LOG "Readgroup : $rg\n";
    print LOG "Library : $lb\n";
    print LOG "Sequencing platform: $pl\n";
    print LOG "Reference genome build is $buildver\n";
    print LOG "dbsnp$dbsnpver is used for variant calling and recalibration (in GATK VQSR).\n";
    print LOG "Java memory usage is limited to $java_mem\n";
    print LOG "Max number of processes: $threads\n";
    if ($fq_toggle) {
	$paired ? print LOG "Two INPUT files detected, PAIRED ends mode\n" : print LOG "SINGLE end mode\n";
    }
    print LOG "Variant calling are run in parallel mode [EXPERIMENTAL].\n" if $quick;
    print LOG "NOTICE: $TMPDIR will be used for storing temporary files\n";

    for my $sample(SeqMule::SeqUtils->get_attr_enum('sample',@obj_list))
    {
	my $result_folder = &get_result_folder($sample);

	print LOG "###################################################\n";
	print LOG "FINAL OUTPUT for $sample:\n";
	print LOG "###################################################\n";
	print LOG "NOTICE: Both consensus results and individual results are listed.\n";
	print LOG "WARNING: consensus results may not be available because some variant callers or aligners may fail to generate output.\n";
	print LOG join "\n", map {$_->file()} 
	(grep {$_->caller eq 'consensus' && $_->filetype eq 'VCF' &&
	$_->sample eq $sample } @obj_list);
	print LOG "\n";
	print LOG join "\n", map {$_->file()} 
	(grep {$_->caller ne 'consensus' && $_->filetype eq 'VCF' &&
	$_->sample eq $sample } @obj_list);
	print LOG "\n";
    }

    close LOG;
    warn "NOTICE: log written to $log\n";
}

sub procFQ
{
    if ( grep { $_ !~ /\.(fq|fastq|fastq\.gz|fq\.gz)$/i } (@fq1_list,@fq2_list) )
    {
	die "ERROR: All FASTQ files must have suffix .fq.gz .fastq.gz .fq or .fastq\n";
    }
    unless ($merge)
    {
	die "ERROR: number of prefixes must equal number of FASTQ files\n" 
	if ($fq1 && $#prefix_list != $#fq1_list);
    }

    die "ERROR: number of FASTQ files for 1st and 2nd read pair must be equal!\n" 
    if ($paired && $#fq1_list != $#fq2_list);



    for my $i(0..$#prefix_list)
    {
	#create symlinks such that all corresponding output have consistent prefix
	#this step is critical for fastqc processing
	my $result_folder = &get_result_folder($prefix_list[$i]);
	#generate a symbolic link for each fastq file
	#place all fastq files belonging to the same sample under sample_result folder
	#we also need to check if the links already exist
	my @fq_idx_range = &SeqMule::Utils::gen_idx_range_by_mergingrule($i,@merging_rule_list);
	for my $j(@fq_idx_range)
	{
	    my @rank = (0,1);
	    my @paired_obj;
	    for my $k(@rank) #are we dealing with first or second fastq in a pair?
	    {
		my $file = ($k == 0? $fq1_list[$j] : $fq2_list[$j]);
		next unless $file;
		my $fq = SeqMule::SeqUtils->new( 	
		    'file'	=> $file,
		    'filetype'	=> 'FASTQ',
		    'sample'	=> $prefix_list[$i],
		    'rgid'	=> $readgroup[$i],
		    'lb'	=> $library[$i],
		    'pl'    	=> $platform[$i],
		    'rank'	=> $k,
		);
		$fq->ancestor($fq);
		my $newfq = $fq->gen_symlink(
		    File::Spec->catfile(
			$result_folder,
			#here I used a trick for join
			#join will ignore an empty list ()
			#undef will still cause join to add another separator, though
			join(".",$fq->sample(),
			    ($merge? &SeqMule::Utils::get_rank_by_mergingrule($i,$j,@merging_rule_list) : ()),
			    $fq->rank(),
			    "fastq",
			    ($fq->file()=~/\.gz$/i ? "gz" : ()), 
			)
		    ));
		$paired_obj[$newfq->rank()] = $newfq;
	    }
	    if(@paired_obj == 2) {
		$paired_obj[0]->sibling($paired_obj[1]);
		$paired_obj[1]->sibling($paired_obj[0]);
	    }
	    push @obj_list,@paired_obj;
	}
    }
#examine first 1000 reads, count bases in ASCII code 33-58 for phred33 and 80-104 for phred64
    $phred=&SeqMule::Utils::phred_score_check($PHRED_SCORE_CHECK_LINECOUNT,(map{$_->file() if $_->filetype() eq 'FASTQ'} @obj_list)) if ($fq_toggle && $phred==1);
}

sub procBAM
{
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
    my $header_check=File::Spec->catfile($install_dir,"bin","secondary","sameBAMSQ");
    if (grep { $_ !~ /\.bam$/ } @bam_list)
    {
	die "ERROR: All BAM files must have suffix .bam\n";
    }

    if ($merge) {
	for my $i(0..$#prefix_list) {
	    my $result_folder = &get_result_folder($prefix_list[$i]);
	    my $onebam = SeqMule::SeqUtils->new(
		'file'		=> File::Spec->catfile($result_folder,$prefix_list[$i].".merge.bam"),
		'filetype'	=> 'BAM',
		'sample'	=> $prefix_list[$i],
	    );
	    #although aligner information is unavaiable, we still need it to figure out
	    #one_aligner_bam later
	    $onebam->aligner('NA');
	    my @bam_idx_range = &SeqMule::Utils::gen_idx_range_by_mergingrule($i,@merging_rule_list);
	    my @one_sample_input_bam;
	    for my $j(@bam_idx_range)
	    {
		my $obj = SeqMule::SeqUtils->new( 	
		    'file'	=> $bam_list[$j],
		    'filetype'	=> 'BAM',
		    'sample'	=> $prefix_list[$i],
		);
		$obj->aligner('NA');
		#only one sample is allowed in each BAM, so we can safely 
		#assume only one sample here
		my $sample_in_bam = &SeqMule::Utils::getBAMSample($samtools,$bam_list[$j]);
		die "ERROR: prefix <<$prefix_list[$i]>> is not equal to sample <<$sample_in_bam>> found in $bam_list[$j]\n"
		unless $prefix_list[$i] eq $sample_in_bam;
		push @one_sample_input_bam,$obj;
	    }
	    $onebam->rg($readgroup[$i]) if ($force_one_rg);

	    #ancestor will be set by merge_bam
	    &merge_bam($onebam,@one_sample_input_bam);
	    #replace BAMs-to-be-merged with merged BAM
	    push @obj_list,$onebam;
	}
    } else {
	if($prefix)
	{
	    $#bam_list==$#prefix_list 
		or die "ERROR: Prefixes for BAM files are optional.\nIf specified, they must equal to BAM files unless merging is used.\n";
	} else
	{
	    @prefix_list=map { my $base=basename $_; $base =~ /(.*)\.bam$/i ;$1} (split /,/,$bam); #in case the file is symbolic link
	    die "ERROR: Duplicate BAM sample found: @prefix_list\nSeqMule cannot use BAM file names as prefixes.\nPlease specify prefix explicitly with '-prefix'.\n" unless @prefix_list == &SeqMule::Utils::uniq(@prefix_list);
	}

	for my $i(0..$#prefix_list)
	{
	    my $result_folder = &get_result_folder($prefix_list[$i]);
	    my $original_bam = SeqMule::SeqUtils->new( 	
		'file'	=> $bam_list[$i],
		'filetype'	=> 'BAM',
		'sample'	=> $prefix_list[$i],
	    );
	    $original_bam->aligner('NA');

	    my $sample_in_bam = &SeqMule::Utils::getBAMSample($samtools,$bam_list[$i]);
	    die "ERROR: prefix $prefix_list[$i] is not equal to sample $sample_in_bam found in $bam_list[$i]\n"
	    unless $prefix_list[$i] eq $sample_in_bam;

	    $original_bam->ancestor($original_bam);
	    my $newbam = $original_bam->gen_symlink(
		File::Spec->catfile(
		    $result_folder,$original_bam->sample().".bam"
		));
	    push @obj_list,$newbam;
	}

	&checkBAMSample($samtools,@obj_list);
    }
    #check contig, try to resolve inconsistency
    for my $local_bam_obj(@obj_list)
    {
	next unless $local_bam_obj->filetype() eq 'BAM';
	#compare chromosome name in ref and BED, complain if they don't match
	my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
	my $local_bam = $local_bam_obj->file();
	my $chr_compare=&SeqMule::Utils::compareChr({
		samtools=>$samtools,
		type1=>'fasta',
		file1=>$local_ref,
		type2=>'bam',
		file2=>$local_bam, 
	    });
	if ($chr_compare==0)
	{
	    die "ERROR: $local_bam contains chromosome names that are not in reference.\n" 
	} elsif ($chr_compare==1)
	{ 
	    warn "NOTICE: contig names in BAM file and reference match with each other.\n";
	} elsif ($chr_compare==2)
	{
	    warn "WARNING: contig names in BAM file do NOT match reference.\n";
	    if ($no_resolve_conflict)
	    {
		die "ERROR: SeqMule cannot continue unless contig names are matched between reference and BAM file.\n";
	    } else
	    {
		#try remove or add 'chr'
		#check @SQ tags, try to fix inconsistent tags
		warn "NOTICE: SeqMule now tries to fix inconsistent contig names. A new copy of BAM file will created.\n";
		my $newbam_obj = $local_bam_obj->clone();
		my $newbam_file = $local_bam_obj->file();
		$newbam_file =~ s/\.bam/.chrmod.bam/;
		$newbam_obj->file($newbam_file);
		$newbam_obj->parent($local_bam_obj);
		$local_bam_obj->child($newbam_obj);

		warn "WARNING: $newbam_file will be overwritten.\n" if -e $newbam_file or -l $newbam_file;
		&SeqMule::Utils::addOrRmChrInBAM($samtools,$local_bam,$newbam_file);

		$local_bam_obj=$newbam_obj;
	    }
	} else
	{
	    die "ERROR: unrecognized return code for contig name comparison.\n";
	}
    }

    #sort all BAMs as we cannot assume they are aligned
    for my $local_bam_obj(@obj_list) {
	next unless $local_bam_obj->filetype() eq 'BAM';
	my $local_bam = $local_bam_obj->file();
	my ($local_prefix)= $local_bam=~/(.*)\.bam$/;
	die "ERROR: $local_bam must have *.bam as file name\n" unless defined $local_prefix;
	my $newbam_obj = $local_bam_obj->clone();
	my $newbam_file="$local_prefix.sort.bam";
	my $newbam_prefix="$local_prefix.sort";
	#we need to write dependency info before command is generated
	#as we need file dependency to resolve command dependency
	$newbam_obj->file($newbam_file);
	$newbam_obj->parent($local_bam_obj);
	$local_bam_obj->child($newbam_obj);

	push @commands, [$threads,
	    "Sort BAM input assuming it is not sorted",
	    "$samtools sort -m ".($wes? $SAMTOOLS_SORT_MEM_EXOME:$SAMTOOLS_SORT_MEM_GENOME)." -\@ $threads $local_bam $newbam_prefix"];

	$local_bam_obj = $newbam_obj; 
	push @removable,$newbam_obj->file();
    }
}

sub confOptCheck
{
#check global options
    if ($buildver !~ /^(hg18|hg19)$/ )
    {
	die "ERROR: Illegal build version $buildver, use hg18 or hg19\n";
    }  #standardize build version
    die "Only support ILLUMINA and IONTORRENT.\n" unless ($pl =~ /illumina|iontorrent/i);
    if ($fq1)
    { 
	die "ERROR: Illegal Phred score scheme: use 1 (auto-detect), 33 or 64\n" 
	unless ($phred==1 or $phred==33 or $phred==64);
    }
    die "ERROR: use integers for threads option: $threads\n" unless $threads=~/^\d+$/;
    die "ERROR: use integers for GATK threads option: $gatk_nt\n" unless $gatk_nt=~/^\d+$/;
    die "ERROR: at least 2 threads required for QUICK mode" if $threads<2 && $quick;

    #check capture file
    if ($capture && $capture=~/^default$/i)
    {
	#see if we should modify default capture file to match custom reference
	warn "NOTICE: use default BED file ${buildver}_exome.bed\n";
	$capture=File::Spec->catfile($install_dir,"misc","${buildver}_exome.bed"); #make sure buildver is assigned a value
    }
    if ($capture)
    {
	$capture = &SeqMule::Utils::abs_path_failsafe($capture);
	die "ERROR: $capture must have .bed suffix.\n" unless $capture=~/\.bed$/;
	die "ERROR: $capture does NOT exist or is empty\n" if !-f $capture or -s $capture <=0;
	#compare chromosome name in ref and BED, complain if they don't match
	my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
	my $chr_compare=&SeqMule::Utils::compareChr({	type1=>'fasta', file1=>$local_ref, type2=>'bed', file2=>$capture, });
	if ($chr_compare==0)
	{
	    die "ERROR: $capture file contain chromosome names that are not in reference.\n" 
	} elsif ($chr_compare==1)
	{ 
	    warn "NOTICE: contig names in capture file and reference match with each other.\n";
	} elsif ($chr_compare==2)
	{
	    warn "WARNING: contig names in capture file do NOT match reference.\n";
	    if ($no_resolve_conflict)
	    {
		die "ERROR: SeqMule cannot continue unless contig names are matched between reference and BED file.\n";
	    }else
	    {
		#try remove or add 'chr'
		warn "NOTICE: SeqMule now tries to resolve inconsistent contig names.\n";
		my $tmp=basename $capture; 
		$tmp=~s/\.bed$/.chrmod.bed/;#fix the naming to avoid generating new file each run
		warn "NOTICE: $tmp will be used to replace $capture.\n";
		if (-e $tmp)
		{
		    my $tmp_chr_compare=&SeqMule::Utils::compareChr({type1=>'fasta', file1=>$local_ref, type2=>'bed', file2=>$tmp, });
		    if ($tmp_chr_compare == 1)
		    {
			$capture=$tmp;
		    } else
		    {
			die "ERROR: SeqMule tries to create $tmp for you, but target exists and its content differs from what SeqMule expects.\nPlease remove or rename it.\n";
		    }
		} else
		{
		    $capture=&SeqMule::Utils::addOrRmChrInBED($capture,$tmp);
		}
	    }
	} else
	{
	    die "ERROR: unrecognized return code for contig name comparison.\n";
	}
    }
    if ($capture && &SeqMule::Utils::checkOverlapBED($capture))
    {
	#remove overlapping regions in BED, generate a new BED if necessary
	warn "NOTICE: SeqMule now tries to resolve overlapping regions in BED file.\n";
	my $tmp = basename $capture; 
	$tmp =~ s/\.bed$/.nooverlap.bed/;#fix the naming to avoid generating new file each run
	warn "NOTICE: $tmp will be used to replace $capture.\n";
	if ((-e $tmp || -l $tmp) && &SeqMule::Utils::checkOverlapBED($tmp))
	{
	    die "ERROR: SeqMule tries to create $tmp for you, but target exists and it contains overlapping regions.\nPlease remove or rename it.\n";
	} else
	{
	    $capture=&SeqMule::Utils::rmOverlapBED($capture,$tmp);
	}
    }

    warn "NOTICE: Input BED file detected, only variants in corresponding regions will be generated.\n" if $capture;
    #get @RG info
    #
    if ($pl =~ /,/)
    {
	@platform=split /,/,$pl;
	die "ERROR: when over 1 platforms are specified, number of platforms must equal number of samples\n" unless @platform == @prefix_list;
    } else
    {
	@platform=map { $pl } @prefix_list;
    }

    if ($lb =~ /,/)
    {
	@library=split /,/,$lb;
	die "ERROR: when over 1 libraries are specified, number of libraries must equal number of samples\n"  unless @library == @prefix_list;
    } else
    {
	@library=map {$lb} @prefix_list;
    }

    #make sure every sample has a RG/PL/LB
    #in principle, we need to specify RG/PL/LB for every input file
    #for now, we just make sure every sample have its own tags
    if ($rg =~ /,/)
    {
	@readgroup=split /,/,$rg;
	die "ERROR: when over 1 readgroup IDs are specified, number of readgroup IDs must equal number of samples\n"   unless @readgroup == @prefix_list;
    } else
    {
	#when only one RG is specified
	#automatically generate a uniq RG for each sample
	@readgroup=map {"${rg}_$prefix_list[$_]"} (0..$#prefix_list);
	$rg=join ',',@readgroup;
    }
}
sub checkForSplit
{
    #bam, ref, capture bed all have been examined and compared
    #warn user if region to be split is too small
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
    my $bed=$capture || &SeqMule::Utils::fa2BED($local_ref);
    &SeqMule::Utils::splitRegion({bed=>$bed,threads=>$threads,rm=>1});
}
sub genScript
{
    warn "Generating script...\n";
    #prepare new tmp folder
    if ($quick) {
	if ($wes) {
	    @small_bed=&SeqMule::Utils::splitRegion({threads=>$threads,bed=>$capture,prefix=>$analysis_prefix});
	} else {
	    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
	    my $bed=$capture || &SeqMule::Utils::fa2BED($local_ref);
	    @small_bed=&SeqMule::Utils::splitRegion({bed=>$bed,threads=>$threads});
	}
	#remove temp BED files after analysis is done
	push @script_unlink_list,@small_bed;
    }
#convert phred64 to phred33, only effective for FQ input
    &convert64to33() if $fq_toggle;

    #read advanced_config file, generate command array
    &parsePipeline();

    &mergeVCF();

    &extractVar if $wes;

    &getConsensusCall();

#output venn, align stats, variant stats, fastqc stats
    &genStat() unless $nostat;
#copy all results of each individual sample to one folder

    unless ($noremove) {
	&keepUseful;
	push @commands,[$threads, "Remove intermediate files","rm -f @removable"] if (@removable);
    }
    if (@script_unlink_list) {
	#-f makes rm keep silent if the file doesn't exist
	push @commands,[$threads,"Remove temporary files","rm -rf @script_unlink_list"];
    }

    &writeLog;
    &genReport() unless ($nostat);
    #generate analysis script
    &writeScript();
}


sub keepUseful
{
    my %rm=map { ($_,1) } @removable;
    my @target=(@bam_files,@vcf_files,@soapaln_file,@consensus_vcf);

    for (@target)
    {
	if ( defined $rm{$_})
	{
	    delete $rm{$_};
	}
    }

    my @index_files;
    for (keys %rm)
    {
	push @index_files,"$1.bai" if /(.*?)\.bam$/i;
	push @index_files,"$1.idx" if /(.*?)\.vcf$/i;
    }

    @removable=(keys %rm,@index_files);
}

sub genReport
{
    my $outdir="${analysis_prefix}_report";
    warn "NOTICE: report folder will be overwritten: $outdir\n" if -d $outdir;
    my $param_file=File::Spec->catfile($outdir,"parameter.txt");
    my $log_file=File::Spec->catfile($outdir,"log.txt");
    my $html_gen=File::Spec->catfile($install_dir,"bin","secondary","html_gen");
    mkdir $outdir unless -d $outdir;

    warn "NOTICE: copying configuration file and log file.\n";
    !system("cp -f $advanced $param_file") and !system("cp -f $log $log_file") or die "Failed to copy configuration or log file: $!\n";
    push @commands,[$threads,"Generating html report","$html_gen $outdir @prefix_list"];
}
#generate various stats used in reports
sub genStat
{
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
    my $seqmule=File::Spec->catfile($install_dir,"bin","seqmule");
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});

    for my $sample(SeqMule::SeqUtils->get_attr_enum('sample',@obj_list)) {
	my @per_sample_obj = grep {$_->sample() eq $sample} @obj_list;
	my $result_folder = &get_result_folder($sample);
	my ($qcstat,$stat_prefix);
	$stat_prefix=File::Spec->catfile($result_folder,$sample);
	$qcstat=$stat_prefix."_qc_stat.txt";

	#QC stat is handled at &fastqc subroutine
	#output venn diagram
	{
	    #we don't include consensus results as they are extracted from other VCFs
	    my @venn_obj = grep { $_->filetype eq 'VCF' and $_->caller ne 'consensus'} @per_sample_obj;
	    my $cmd_common = "$seqmule stats -tmpdir $TMPDIR ".
	    #each VCF may contain multiple samples
	    #sample names will match samples associated with obj for FASTQ/BAM with/without merging
	    " -prefix $stat_prefix -ref $local_ref -s $sample ";

	    if(@venn_obj <= 5 && @venn_obj >=2) {
		push @commands,[$threads,"Generate Venn digram","$cmd_common -venn ".join(',',(map {$_->file()} @venn_obj))];
	    } else {
		warn "WARNING: For each sample, there are >5 or <2 VCF files, no Venn diagram will be drawn.\n";
	    }
	}
	#output alignment and coverage statistics
	#only output statistics about one BAM, can be improved later
	if (my ($bam_obj)=grep { $_->filetype eq 'BAM' } (@per_sample_obj)) {#only report one BAM 
	    my $bam = $bam_obj->file();
	    warn "NOTICE: SeqMule only reports statistics from ONE BAM file.\n";
	    push @commands,[$threads,"Generate alignment and coverage stat",
		"$seqmule stats -tmpdir $TMPDIR -bam $bam -aln -prefix $stat_prefix ".($wes?" -capture $capture ":"")];
	}
	#output variant statistics
	if (my @vcf_obj = grep { $_->filetype eq 'VCF' } (@per_sample_obj)) {
	    my @vcf = map{$_->file()} @vcf_obj;
	    my $genVarStat=File::Spec->catfile($install_dir,"bin/secondary/genVarStat");
	    push @commands,[$threads,"Generate variant stat","$genVarStat -s $sample $stat_prefix @vcf"];
	}
    }
}
sub mergeVCF
{
    #merge VCF because variants are called over different regions
    #under quick mode
    #all VCFs that are supposed to be merged into one VCF
    #are siblings to each other
    
    #first figure out what VCFs to merge (only include rank=0)
    my @vcf_to_merge_rank0;
    for my $vcf_obj(@obj_list) {
	next unless $vcf_obj->rank == 0 and 
	$vcf_obj->filetype eq 'VCF' and
	$vcf_obj->sibling > 1;
	push @vcf_to_merge_rank0,$vcf_obj;
    }

    for my $vcf_obj(@vcf_to_merge_rank0)
    {
	my @sibling_vcf_obj = ($vcf_obj,$vcf_obj->sibling());
	#if we decide to merge, remove the VCFs to be merged from VCF pool
	SeqMule::SeqUtils->rmObjFromArray(
	    target=>\@sibling_vcf_obj,
	    all=>\@obj_list,
	);
	my ($local_prefix) = $vcf_obj->file() =~ /(.*?)\.vcf$/i;
	my $merged_vcf_obj = $vcf_obj->clone();
	my $expect_merged_vcf_obj = $vcf_obj->clone();
	my $out_file="${local_prefix}_union.vcf";
	my $expect_out_file="$local_prefix.vcf";

	$merged_vcf_obj->file($out_file);
	$merged_vcf_obj->parent(@sibling_vcf_obj);
	$expect_merged_vcf_obj->file($expect_out_file);
	$expect_merged_vcf_obj->parent($merged_vcf_obj);
	map {$_->child($merged_vcf_obj)} @sibling_vcf_obj;

	push @commands,[$threads,"Merge split VCF",&vcf_merge_cmd_gen($local_prefix,map{$_->file()}@sibling_vcf_obj)];
	push @commands,[$threads,"Rename VCF","mv -f $out_file $expect_out_file"];

	push @obj_list,$expect_merged_vcf_obj;
	#only siblings here!!, why?
	#the vcf_obj->file() will be used as name of merged VCF
	#so we need to keep it
	push @script_unlink_list,(map{$_->file()} $vcf_obj->sibling());
	push @script_unlink_list,(map {"$_.idx"} (map{$_->file()} @sibling_vcf_obj));
    }
}

sub getConsensusCall
{
    #merge vcfs by prefix (samplename)
    my $exe=File::Spec->catfile($install_dir,"bin","seqmule");
    #we regarde "consensus" as a calling method
    my $caller = "consensus";
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
    my $cmd_common = "$exe stats -tmpdir $TMPDIR -ref $local_ref ".
    " -jmem $java_mem ".
    " -t ".($threads>$gatk_nt? $gatk_nt:$threads); #use smaller one
    $cmd_common .= " -N $minN" if $minN;

    for my $sample(SeqMule::SeqUtils->get_attr_enum('sample',@obj_list)) {
	my @vcf_obj = grep {$_->sample eq $sample and $_->filetype eq 'VCF'} @obj_list;

	#at least 2 VCFs are required for each sample to get consensus
	next unless @vcf_obj>1;
	warn
	"WARNING: user requests to extract consensus calls from at least $minN files,\n",
	"WARNING: but there are only ",scalar(@vcf_obj)," files.\n" and next
	if $minN && @vcf_obj<$minN;

	my $outdir = &get_result_folder($sample);
	#this is used for seqmule stats command
	my $out_prefix = File::Spec->catfile($outdir,${sample}.($wes? ".extract":""));
	my $out = $out_prefix."_consensus.vcf";
	my $new_vcf_obj = $vcf_obj[0]->clone();

	$new_vcf_obj->caller($caller);
	$new_vcf_obj->parent(@vcf_obj);
	$new_vcf_obj->file($out);
	map {$_->child($new_vcf_obj) } @vcf_obj;

	my $cmd = $cmd_common;
	$cmd .= " -c-vcf ".join(",",
	    map{$_->file()} 
	    (sort 
	    { $VARIANT_QUAL_PRIORITY_LIST{$a->caller} <=> 
		$VARIANT_QUAL_PRIORITY_LIST{$b->caller} } 
	    @vcf_obj)
	);
	$cmd .= " -p $out_prefix ";
	push @commands,[$threads,"Extract consensus calls",$cmd];
	push @obj_list,$new_vcf_obj;
	#right now we keep all VCFs
	#SeqMule::SeqUtils->rmObjFromArray(
	#    target=>\@vcf_obj,
	#    all=>\@obj_list,
	#);
    }
}

sub extractVar
{
    #extract variants in BED region
    my $exe=File::Spec->catfile($install_dir,"bin","seqmule");
    my $cmd_common="$exe stats -tmpdir $TMPDIR ";
    $cmd_common .= " -capture $capture " if $wes;
    #1.vcf => 1.extract.vcf (seqmule stats default naming rule)
    for my $vcf_obj(@obj_list)
    {
	next unless $vcf_obj->filetype eq 'VCF';
	my $vcf = $vcf_obj->file();
	if ($vcf =~ /(.*)\.vcf$/i)
	{
	    my $local_prefix=$1;
	    my $out="$local_prefix.extract.vcf";
	    my $new_vcf_obj = $vcf_obj->clone();
	    $new_vcf_obj->file($out);
	    $new_vcf_obj->parent($vcf_obj);
	    $vcf_obj->child($new_vcf_obj);

	    my $cmd = $cmd_common;
	    $cmd .= " -vcf $vcf -p $local_prefix";
	    push @commands,[$threads,"Extract variants in custom regions",$cmd];
	    $vcf_obj = $new_vcf_obj;
	    push @removable,$vcf;
	} else
	{
	    die "ERROR: Failed to get VCF prefix (*.vcf format expected): $vcf\n";
	}
    }
}

sub vcf_merge_cmd_gen
{
    my $out_prefix=shift;
    my @vcf=@_;
    my $exe=File::Spec->catfile($install_dir,"bin","seqmule");
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});

    my $cmd;

    $cmd=
    "$exe stats -tmpdir $TMPDIR -ref $local_ref".
    " -jmem $java_mem".
    " -t ".($threads>$gatk_nt? $gatk_nt:$threads). #use smaller one
    " -u-vcf ".join(",",@vcf).
    " -p $out_prefix";

    return $cmd;
}

sub parsePipeline
{
    my @advanced_config_lines=&SeqMule::Utils::parsePipeline($advanced);
    $advanced="$analysis_prefix.config";
    warn "NOTICE: Analysis configuration log will be overwritten: $advanced\n" if -f $advanced or -l $advanced;
    open OUT,'>',$advanced or die "Failed to write to $advanced: $!\n";
    print OUT "#This file is ONLY for LOGGING purposes, so do NOT run SeqMule with it.\n";

    #walk through advanced_config to figure each step
    my $no=0;
    for (0..$#advanced_config_lines)
    {
	my ($program,$subprogram,$option_ref)=@{$advanced_config_lines[$_]};

	if ($program=~/^samtools$/i && $subprogram=~/rmdup/i && $capture && $wes)
	{
	    if (&SeqMule::Utils::bed2total($capture)<$RMDUP_MIN_LEN)
	    {
		warn "NOTICE: capture region smaller than $RMDUP_MIN_LEN, skip removal of duplicates (use --forceRmDup to enable it).\n"
		    and next unless $force_rm_dup or $option_ref->{forceRm};
	    }
	}

	$no++;
	warn "Generating: $no,$program,$subprogram\n" if $verbose;
	&cmd_gen($no,$program,$subprogram,$option_ref);

	print OUT "${no}P_${program}",($subprogram? "_$subprogram":""),"=1\n";
	while (my ($opt,$val)=each %$option_ref)
	{
	    print OUT "o_${program}_$opt=$val\n";
	}
    }

    close OUT;

    #complain about some particular configuration
    if ( $merge && grep {/soap/} (SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list)) )
    {
	die "ERROR: SOAPaligner alignments cannot be merged.\n";
    }
    if ($multi_sample_calling && grep { /soapsnp/} SeqMule::SeqUtils->get_attr_enum('caller',@obj_list))
    {
	die "ERROR: SOAPsnp does not support multi-sample variant calling\n";
    }

    warn "NOTICE: Final configurations written to $advanced\n";
}

sub writeScript
{
    $script_file="${analysis_prefix}.script";
    warn "NOTICE: script file will be overwritten: $script_file\n" if -f $script_file;
    &SeqMule::Parallel::writeParallelCMD ($install_dir,$script_file,$threads,@commands);
}

sub convert64to33
{
    my $exe=File::Spec->catfile($install_dir,"bin","secondary","phred64to33");
    if ($phred==64)
    {
	for my $i(@obj_list)
	{
	    next unless $i->filetype() eq 'FASTQ';
	    my $newobj = $i->clone();
	    my $file=$i->file();
	    $file =~ s/(.*)\.(fq|fastq|fastq\.gz|fq\.gz)$/${1}_phred33.$2/;
	    $newobj->file($file);
	    $newobj->parent($i);
	    $i->child($newobj);

	    push @commands,[$threads,"Convert phred64 to phred33",join(" ",$exe,$i->file(),$newobj->file())];
	    $i = $newobj;
	    push @script_unlink_list,$newobj->file();
	}
	$phred=33;
    }
}

sub get_result_folder
{
    my $sample = shift;
    my $result_folder="${sample}_result";
    mkdir $result_folder unless -d $result_folder;
    #my $istumor = shift;
    #if($somatic_toggle)
    #{
    #    if($istumor)
    #    {
    #        my $tumor_result_folder=File::Spec->catdir($result_folder,"${sample}_tumor_result");
    #        mkdir $tumor_result_folder unless -d $tumor_result_folder;
    #        return $tumor_result_folder;
    #    } else
    #    {
    #        my $normal_result_folder=File::Spec->catdir($result_folder,"${sample}_normal_result");
    #        mkdir $normal_result_folder unless -d $normal_result_folder;
    #        return $normal_result_folder;
    #    }
    #} else
    #{
    return $result_folder;
    #}
}
sub merge_bam
{
    my $onebam_obj = shift;
    my @other_bam_obj = @_;
    my @other_bam_file = map {$_->file()} @other_bam_obj;
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
    my $header_check=File::Spec->catfile($install_dir,"bin","secondary","sameBAMSQ");

    $onebam_obj->ancestor(@other_bam_obj);
    $onebam_obj->parent(@other_bam_obj);
    map { $_->child($onebam_obj) } @other_bam_obj;

    #force single sample in each BAM
    &checkBAMSample($samtools,@other_bam_obj);
    #check BAM @SQ header
    push @commands, [$threads,"Check BAM header before merging", "$header_check $samtools ".join(" ",@other_bam_file)];

    if ($force_one_rg)
    {
	my $exe=File::Spec->catfile($install_dir,"bin","secondary","mergeBAMOneRG");
	push @commands, [$threads,
	    "Merge BAM into one readgroup",
	    #readgroup has been changed before calling &merge_bam
	    #so no need to change it here
	    "$exe $samtools $threads ".$onebam_obj->rg()." ".$onebam_obj->file()." $TMPDIR ".join(" ",@other_bam_file)];
    } elsif ($union_rg)
    {
	my $exe=File::Spec->catfile($install_dir,"bin","secondary","mergeBAMUnionRG");
	#check READGROUP ID, they must be unique, o/w use '-forceOneRG' or '-unionRG'
	push @commands, [$threads,
	    "Merge BAM without changing readgroup",
	    "$exe $samtools $threads ".$onebam_obj->file()." $TMPDIR ".join(" ",@other_bam_file)];
    } else
    {
	#check READGROUP ID, they must be unique, o/w use '-forceOneRG' or '-unionRG'
	if (&SeqMule::Utils::checkDuplicateRGID($samtools,@other_bam_obj)) 
	{
	    die "ERROR: SeqMule cannot decide how to merge BAM files with duplicate readgroup IDs. Please use '--forceOneRG' or '--unionRG' option.\n";
	} else 
	{
	    my $exe=File::Spec->catfile($install_dir,"bin","secondary","mergeBAMUnionRG");
	    push @commands, [$threads,
		"Merge BAM without changing readgroup",
		"$exe $samtools $threads ".$onebam_obj->file()." $TMPDIR ".join(" ",@other_bam_file)];
	}
    }
}

#######################HELPER SUBROUTINES#############################
sub check_obj
{ #show all attributes of objects, used for debug
    map {$_->dump()} @_;
    $|=1; #flush buffer
}
sub remove_obj_from_array
{ #remove obj in target from obj in all
    my $opt = shift @_;
    my $target = $opt->{target};
    my $all = $opt->{all};

    for my $i(@$target)
    {
	for my $j(@$all)
	{
	    if($i->id() == $j->id())
	    {
		$j = undef;
	    }
	}
    }
    @$all = grep {defined $_} @$all;
}
sub get_gatk_nt
{
    my ($total,$gatk)=@_;
    if ($total>= $gatk) 
    {
	return $gatk;
	warn "NOTICE: Set GATK genotype calling threads to $gatk for safety\n" if $total>1;
    } else 
    {
	return $total;
    }
}
sub checkBAMSample
{
    my $samtools=shift;
    my @bam_obj=@_;
    my $first_sample;

    warn "NOTICE: Checking sample names in BAM...\n";
    for (@bam_obj) {
	my @local_sample=&SeqMule::Utils::getBAMSample($samtools,$_->file());
	die "ERROR: One and only one sample allowed in each BAM, found @local_sample.\n" if @local_sample!=1;
	$first_sample=$local_sample[0] unless defined $first_sample;
	die "ERROR: Found two different sample names in BAM input when merging is enabled: $local_sample[0] $first_sample\n" if (defined $first_sample && $first_sample ne $local_sample[0] && $merge);
    }
}
#######################END OF HELPER SUBROUTINES#############################


__END__


=head1 NAME

SeqMule an automatic pipeline for next-generation sequencing data analysis

=head1 SYNOPSIS

seqmule <options>

For details about each option, please use 'seqmule -h':

Options:

	--prefix,-p		  comma-delimited list of sample names, will be used for output file naming.
				  Mandatory for FASTQ input or BAM input with merge enabled.
	-a <FASTQ>             	  1st FASTQ file (or comma-delimited list)
	-b <FASTQ>             	  2nd FASTQ file (or comma-delimited list)
	--bam <BAM>		  BAM file (or comma-delimited list). Exclusive of -a,-b options.
	--merge,-m		  merge FASTQ or BAM files before analysis
	--mergingrule <TEXT>	  comma-delimited numbers for how many files merged for each sample.
				  Default: equal number of files for each samples.
	-ms			  do multiple-sample variant calling (only valid for GATK,VarScan and SAMtools)

	-a2 <FASTQ>            	  1st FASTQ file (or comma-delimited list) from tumor tissue.
	-b2 <FASTQ>            	  2nd FASTQ file (or comma-delimited list) from tumor tissue.
	--bam2 <BAM>		  BAM file (or comma-delimited list) from tumor tissue. Exclusive of FASTQ input.
	-N <INT>		  if more than one set of variants are generated, extract variants shared by at least INT VCF output
	--build <hg18,hg19>	  genome build. Default is hg19.
	--readgroup,-rg <TEXT>    readgroup ID. Specify one ID for all input or a comma-separated list. Default: READGROUP_[SAMPLE NAME]
	--platform,-pl <TEXT>	  sequencing platform, only Illumina and IonTorrent are supported. Specify one platform for all input or a comma-separated list. Only for FASTQ input. Default: ILLUMINA.
	--library,-lb <TEXT>	  sequencing library. Specify one library for all input or a comma-separated list. Only for FASTQ input. Default: LIBRARY.
	--forceOneRG		  force use of one readgroup ID for BAM when merging is enabled. See details.
	--unionRG		  When merging BAM files, combine reads with same readgroup ID, keep reads with different readgroup IDs intact.
	--phred <1,33,64>	  Phred score scheme. 1 is default, for auto-detection. Has no effect on BAM input.
	--wes,-e                  the input is captured sequencing data
	--wgs,-g		  the input is whole-genome sequencing data
	--capture <BED>		  calculate coverage stats and extract (or call) variants over the regions defined by this file. If you do not have a custom BED file, use '-capture default' to use default BED file.
	--no-resolve-conflict	  seqmule will NOT try to resolve any conflict among BED, BAM and reference. Run 'seqmule pipeline -h' for details.
	--threads,-t <INT>	  number of threads. Default: 1.
	--quick,-q		  enable parallel processing at variant calling
	--jmem <STRING>		  max memory used for java virtual machine. Default: 1750m.
	--gatknt <INT>		  number of threads for GATK. Prevent GATK from opening too many files. Default: 2.
	--advanced [FILE]	  generate or use an advanced configuration file
	--tmpdir <DIR>		  use DIR for storing large temporary files. Default: $TMPDIR(in your ENV variables) or /tmp
	--norun,-nr		  do NOT run analysis, only generate script
	--nostat,-ns 		  do NOT generate statistics
	--norm			  do NOT remove intermediate SAM, BAM and other files
	--forceRmDup		  force removal of duplicates. This overrides default behavior which disables duplicate removal for small capture regions.

	--ref <FILE>              reference genome. Override default database (the following is the same). 
				  When you use custom databases, make sure they are compatible with each other.
	--index <PREFIX>          prefix for bowtie, bowtie2, soap index files. Including path.
	--bowtie <PREFIX>         prefix ONLY for bowtie index files, including path
	--bowtie2 <PREFIX>        prefix only for bowtie2 index files, including path
	--soap <PREFIX>           prefix only for soap index files, including path
	--hapmap <FILE>           HapMap VCF file for variant quality recalibration
	--dbsnp <FILE>            dbSNP VCF file for variant quality recalibration
	--dbsnpver,-dv <INT>      dbSNP version for variant quality recalibration. By default, it's 138.
	--kg <FILE>               1000 genome project VCF file for variant quality recalibration
	--indel <FILE>		  Indel VCF file for GATK realignment and VQSR

	--verbose,-v		  verbose output
	--help,-h		  show this message

	EXAMPLE	

	#generate a copy of 'advanced_config' for modification. You can find some predefined configurations under 'seqmule/misc/predefined_config' folder.
	seqmule pipeline -advanced

	#run analysis using custom advanced configuration on captured sequencing data. 1.fastq is raw data for first reads in paired-end sequencing, and 2.fastq is for second reads. Number of CPUs is 12, @RG tag is 'READGROUP' plus your sample name which is specified by -prefix. all output files have prefix 'exomeData' followed by an underscore. An html report will be generated automatically using default BED file(from SureSelect manufacturer).
	seqmule pipeline -a 1.fastq -b 2.fastq -prefix exomeData -threads 12 -rg READGROUP -e -advanced advanced_config -capture default

	#same as above, except that coverage stats will be calculated using custom BED file
	seqmule pipeline -a 1.fastq -b 2.fastq -prefix exomeData -threads 12 -rg READGROUP -e -advanced advanced_config -capture region.bed

	#same as above except that the data comes from whole-genome sequencing.
	seqmule pipeline -a 1.fastq -b 2.fastq -prefix genomeData -threads 12 -rg READGROUP -g -advanced advanced_config

	#same as above except that no report webpage will be generated
	seqmule pipeline -a 1.fastq -b 2.fastq -prefix genomeData -threads 12 -rg READGROUP -g -advanced advanced_config -nostat

	#Input is multi-sample, paired-end exome or other captured sequencing data, output files have 'sampleA' prefix for sampleA.1.fq and sampleA.2.fq, and 'sampleB' for sampleB.1.fq and sampleB.2.fq. FQ is just abbreviation for FASTQ. Without custom advanced_config, default pipeline 'bwa+gatk+samtools' will be used.
	seqmule pipeline -a sampleA.1.fq,sampleB.1.fq -b sampleA.2.fq,sampleB.2.fq -e -prefix sampleA,sampleB -capture default

	#same as above except that multi-sample variant calling is enabled. Multi-sample variant calling means we assume the two samples come from the same family.
	seqmule pipeline -a sampleA.1.fq,sampleB.1.fq -b sampleA.2.fq,sampleB.2.fq -e -prefix sampleA,sampleB

	#analysis beginning with BAM files. BAM files store the alignment information of your data. Output files will have same prefixes as BAM files.
	seqmule pipeline -bam 1.bam,2.bam,3.bam -e -capture default

	#same as above, except the BAM files will be merged before proceeding. Output has mandatory prefix 'sample' here. Merging is useful when you sequenced your sample multiple times and want to pool the data together. 12 CPUs are used.
	seqmule pipeline -bam 1.bam,2.bam,3.bam -e -merge -prefix sample -t 12

	#same as above except that the variant calling will be carried out in a parallel fashion. 12 CPUs are used.
	seqmule pipeline -bam 1.bam,2.bam,3.bam -e -merge -prefix sample -quick -t 12

	#analyze gzipped FASTQ files (.fq.gz) and unzipped files (.fq). Gzipped files will be unpacked temporarily and be removed after analysis.
	seqmule pipeline -a sample1.1.fq.gz,sample2.1.fq -b sample1.2.fq.gz,sample2.2.fq -e -prefix sample1,sample2 -capture default

	#merge multiple pairs of FASTQ files and do multiple sample variant calling
	#--forceOneRG must be used along with -rg to assign same @RG tag to input files
	#input files belonging to same sample have same @RG tag
	#--mergingrule 1,1,2 means sample1 has 1 (pair of) input file, sample2 has 1 (pair of) input file, sample3 has 2 (pairs of) input files.
	seqmule pipeline -a sample1.1.1.fastq,sample2.1.1.fastq,sample3.1.1.fastq,sample3.2.1.fastq -b sample1.1.2.fastq,sample2.1.2.fastq,sample3.1.2.fastq,sample3.2.2.fastq -p sample1o3,sample2o3,sample3o3 -g -merge --forceOneRG -rg READGROUP --mergingrule 1,1,2 -ms

	#merge with default method
	#if 4 (pairs of) input files are given for 2 samples, each sample gets 2 by default
	#here multi-sample variant calling is not enabled
	seqmule pipeline -a sample1.1.1.fastq,sample1.2.1.fastq,sample2.1.1.fastq,sample2.2.1.fastq -b sample1.1.2.fastq,sample1.2.2.fastq,sample2.1.2.fastq,sample2.2.2.fastq -p sample1o2,sample2o2 -g -merge --forceOneRG -rg READGROUP 


=head1 OPTIONS

=over 8

=item B<--platform>

sequencing platform, default is illumina. Only IonTorrent and Illumina are supported currently

=item B<--ref>

specify the reference genome, otherwise it searches inside installation path for default reference genome

=item B<--index>

specify prefix for index files, if a program-specific index prefix is supplied, this option will be omitted. If no index prefix is supplied, downloaded files will be searched for index

=item B<--rg>

Specify the readgroup of '@RG' tag in SAM/BAM file. Usually one combination of sample/library/lane constitutes a readgroup, but users can make their own choices. Default is 'READGROUP'.

=item B<--forceOneRG>

Force all readgroups to be one readgroup when merging is enabled. Some algorithms account for different variabiliy associated with reads from the different readgroups. This option is only effective for BAM input.

=item B<--unionRG>

When merging BAM files, combine reads with same readgroup ID, keep reads with different readgroup IDs intact.

=item B<--mergingrule>

comma-delimited numbers for how many files merged for each sample. For example, if your prefix list is sample1,sample2, and mergingrule is 2,3, then the first 2 input files are merged as sample1 and the last 3 files are merged as sample2. Positive integers are expected. Default: equal number of files for each samples. So if you have two samples and 4 fastq/bam files, then the first two are merged for 1st sample, the last two are merged for 2nd sample.

=item B<--hapmap>

specify the HapMap VCF file for variant quality recalibration, otherwise it searches for default file within installation directory

=item B<--dbsnp>

specify the dbSNP file for variant quality recalibration, otherwise it searches for default file within installation directory

=item B<--kg>

specify the 1000 genome project VCF file for variant quality recalibration, otherwise it searches for default file inside installation directory

=item B<--no-resolve-conflict>

By default, SeqMule will add or trim leading 'chr' to the BED file or BAM file to make the contig names consistent with reference. Modified BED and BAM will be saved to a new file.

=back

=head1 DESCRIPTION

SeqMule automatizes analysis of next-generation sequencing data by simplifying program installation, downloading of various databases, generation of analysis script, and customization of your pipeline.

=cut
